<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>org.gridgain.scalar.pimps.ScalarCacheProjectionPimp</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../../../lib/template.css" />
      <script type="text/javascript" src="../../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../../lib/tools.tooltip.js"></script>
    
        <link type='text/css' rel='stylesheet' href='http://www.gridgain.com/sh3.0/styles/shCore.css'/>
<link type='text/css' rel='stylesheet' href='http://www.gridgain.com/sh3.0/styles/shThemeMidnight.css'/>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/src/shCore.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/src/shLegacy.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushJava.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushPlain.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushJScript.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushXml.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushScala.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushGroovy.js'></script>
</head>

        <body onload="sh_highlightDocument('../lib/', '.min.js');" class="type">
      <div id="definition">
        <a title="Go to companion" href="ScalarCacheProjectionPimp$.html"><img src="../../../../lib/class_to_object_big.png" /></a>
        <p id="owner"><a name="org" class="extype" href="../../../package.html">org</a>.<a name="org.gridgain" class="extype" href="../../package.html">gridgain</a>.<a name="org.gridgain.scalar" class="extype" href="../package.html">scalar</a>.<a name="org.gridgain.scalar.pimps" class="extype" href="package.html">pimps</a></p>
        <h1><a title="Go to companion" href="ScalarCacheProjectionPimp$.html">ScalarCacheProjectionPimp</a></h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">ScalarCacheProjectionPimp</span><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="result"> extends <span name="scalaz.PimpedType" class="extype">PimpedType</span>[<span name="org.gridgain.grid.cache.GridCacheProjection" class="extype">GridCacheProjection</span>[K, V]] with <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      
      <div class="fullcommenttop" id="comment"><div class="comment cmt"><h4>Overview</h4><p>Defines Scalar &quot;pimp&quot; for <code>GridCacheProjection</code> on Java side.</p><p>Essentially this class extends Java <code>GridCacheProjection</code> interface with Scala specific
API adapters using primarily implicit conversions defined in <code>ScalarConversions</code> object. What
it means is that you can use functions defined in this class on object
of Java <code>GridCacheProjection</code> type. Scala will automatically (implicitly) convert it into
Scalar's pimp and replace the original call with a call on that pimp.</p><p>Note that Scalar provide extensive library of implicit conversion between Java and
Scala GridGain counterparts in <code>ScalarConversions</code> object</p><h4>Suffix '$' In Names</h4><p>Symbol <code>$</code> is used in names when they conflict with the names in the base Java class
that Scala pimp is shadowing or with Java package name that your Scala code is importing.
Instead of giving two different names to the same function we've decided to simply mark
Scala's side method with <code>$</code> suffix.
</p></div><dl class="attributes block"> <dt>Version</dt><dd><p>GridGain 4.0.3 build: 14052012
</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], <span name="scala.collection.IterableLike" class="extype">IterableLike</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]], <span name="scala.Equals" class="extype">Equals</span>, <span name="scala.collection.GenIterable" class="extype">GenIterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], <span name="scala.collection.GenIterableLike" class="extype">GenIterableLike</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]], <span name="scala.collection.Traversable" class="extype">Traversable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], <span name="scala.collection.GenTraversable" class="extype">GenTraversable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], <span name="scala.collection.generic.GenericTraversableTemplate" class="extype">GenericTraversableTemplate</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>], <span name="scala.collection.TraversableLike" class="extype">TraversableLike</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]], <span name="scala.collection.GenTraversableLike" class="extype">GenTraversableLike</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]], <span name="scala.collection.Parallelizable" class="extype">Parallelizable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.parallel.ParIterable" class="extype">ParIterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]], <span name="scala.collection.TraversableOnce" class="extype">TraversableOnce</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], <span name="scala.collection.GenTraversableOnce" class="extype">GenTraversableOnce</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], <span name="scala.collection.generic.FilterMonadic" class="extype">FilterMonadic</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]], <span name="scala.collection.generic.HasNewBuilder" class="extype">HasNewBuilder</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]], <span name="scalaz.PimpedType" class="extype">PimpedType</span>[<span name="org.gridgain.grid.cache.GridCacheProjection" class="extype">GridCacheProjection</span>[K, V]], AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div><div class="toggleContainer block">
          <span class="toggle">Known Subclasses</span>
          <div class="subClasses hiddenContent"><a name="org.gridgain.scalar.pimps.ScalarCachePimp" class="extype" href="ScalarCachePimp.html">ScalarCachePimp</a></div>
        </div></div>
    

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
            </div>
        <div id="ancestors">
              <span class="filtertype">Inherited</span>
              <ol><li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li></ol>
              <ol id="linearization"><li name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp" class="in"><span>ScalarCacheProjectionPimp</span></li><li name="scala.collection.Iterable" class="in"><span>Iterable</span></li><li name="scala.collection.IterableLike" class="in"><span>IterableLike</span></li><li name="scala.Equals" class="in"><span>Equals</span></li><li name="scala.collection.GenIterable" class="in"><span>GenIterable</span></li><li name="scala.collection.GenIterableLike" class="in"><span>GenIterableLike</span></li><li name="scala.collection.Traversable" class="in"><span>Traversable</span></li><li name="scala.collection.GenTraversable" class="in"><span>GenTraversable</span></li><li name="scala.collection.generic.GenericTraversableTemplate" class="in"><span>GenericTraversableTemplate</span></li><li name="scala.collection.TraversableLike" class="in"><span>TraversableLike</span></li><li name="scala.collection.GenTraversableLike" class="in"><span>GenTraversableLike</span></li><li name="scala.collection.Parallelizable" class="in"><span>Parallelizable</span></li><li name="scala.collection.TraversableOnce" class="in"><span>TraversableOnce</span></li><li name="scala.collection.GenTraversableOnce" class="in"><span>GenTraversableOnce</span></li><li name="scala.collection.generic.FilterMonadic" class="in"><span>FilterMonadic</span></li><li name="scala.collection.generic.HasNewBuilder" class="in"><span>HasNewBuilder</span></li><li name="scalaz.PimpedType" class="in"><span>PimpedType</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
            </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div class="members" id="constructors">
              <h3>Instance Constructors</h3>
              <ol><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#this" data-isabs="false">
      <a id="this:ScalarCacheProjectionPimp[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">ScalarCacheProjectionPimp</span><span class="params">()</span>
      </span>
      </h4>
      
    </li></ol>
            </div>

        <div class="types members" id="types">
              <h3>Type Members</h3>
              <ol><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#EntryPred" data-isabs="false">
      <a id="EntryPred:EntryPred"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">EntryPred</span><span class="result"> = Function1[_ <span class='angle_bracket'>&gt;</span>: org.gridgain.grid.cache.GridCacheEntry[K,V], Boolean]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#KeyPred" data-isabs="false">
      <a id="KeyPred:(K) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">KeyPred</span><span class="result"> = (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias</p><div class="fullcomment"><div class="comment cmt"><p>Type alias</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#KvPred" data-isabs="false">
      <a id="KvPred:(K, V) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">KvPred</span><span class="result"> = (K, V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd></dl></div>
    </li><li visbl="prt" name="scala.collection.TraversableLike#Self" data-isabs="false">
      <a id="Self:Self"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Self</span><span class="result"> = <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#ValuePred" data-isabs="false">
      <a id="ValuePred:(V) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">ValuePred</span><span class="result"> = (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias</p><div class="fullcomment"><div class="comment cmt"><p>Type alias</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd></dl></div>
    </li></ol>
            </div>

        

        <div class="values members" id="values">
              <h3>Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#++" data-isabs="false">
      <a id="++[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V], That](GenTraversableOnce[B])(CanBuildFrom[Iterable[GridCacheEntry[K, V]], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $plus$plus">++</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.GenTraversableOnce" class="extype">GenTraversableOnce</span>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#++:" data-isabs="false">
      <a id="++:[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V], That](Traversable[B])(CanBuildFrom[Iterable[GridCacheEntry[K, V]], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $plus$plus$colon">++:</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.Traversable" class="extype">Traversable</span>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#++:" data-isabs="false">
      <a id="++:[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V], That](TraversableOnce[B])(CanBuildFrom[Iterable[GridCacheEntry[K, V]], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $plus$plus$colon">++:</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.TraversableOnce" class="extype">TraversableOnce</span>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#+=" data-isabs="false">
      <a id="+=((K, V),(K, V),(K, V)*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $plus$eq">+=</span><span class="params">(<span name="kv1">kv1: (K, V)</span>, <span name="kv2">kv2: (K, V)</span>, <span name="kvs">kvs: (K, V)*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Operator alias for the same function <code>putAll$</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Operator alias for the same function <code>putAll$</code>.
</p></div><dl class="paramcmts block"><dt class="param">kv1</dt><dd class="cmt"><p>Key-value pair to store in cache.</p></dd><dt class="param">kv2</dt><dd class="cmt"><p>Key-value pair to store in cache.</p></dd><dt class="param">kvs</dt><dd class="cmt"><p>Optional key-value pairs to store in cache.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#putAll(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#+=" data-isabs="false">
      <a id="+=((K, V),EntryPred*):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $plus$eq">+=</span><span class="params">(<span name="kv">kv: (K, V)</span>, <span name="p">p: EntryPred*</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Operator alias for the same function <code>putx$</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Operator alias for the same function <code>putx$</code>.
</p></div><dl class="paramcmts block"><dt class="param">kv</dt><dd class="cmt"><p>Key-Value pair to store in cache.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional filter to check prior to putting value in cache. Note
     that filter check is atomic with put operation.</p></dd><dt>returns</dt><dd class="cmt"><p><code>True</code> if value was stored in cache, <code>false</code> otherwise.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#putx(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#-=" data-isabs="false">
      <a id="-=(K,K,K*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $minus$eq">-=</span><span class="params">(<span name="k1">k1: K</span>, <span name="k2">k2: K</span>, <span name="ks">ks: K*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Operator alias for the same function <code>remove$</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Operator alias for the same function <code>remove$</code>.
</p></div><dl class="paramcmts block"><dt class="param">k1</dt><dd class="cmt"><p>1st key to remove.</p></dd><dt class="param">k2</dt><dd class="cmt"><p>2nd key to remove.</p></dd><dt class="param">ks</dt><dd class="cmt"><p>Optional sequence of additional keys to remove.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#removeAll(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#-=" data-isabs="false">
      <a id="-=(K,EntryPred*):V"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $minus$eq">-=</span><span class="params">(<span name="k">k: K</span>, <span name="p">p: EntryPred*</span>)</span><span class="result">: V</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Operator alias for the same function <code>remove$</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Operator alias for the same function <code>remove$</code>.
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key whose mapping is to be removed from cache.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional filters to check prior to removing value form cache. Note
     that filter is checked atomically together with remove operation.</p></dd><dt>returns</dt><dd class="cmt"><p>Previous value associated with specified key, or <code>null</code>
     if there was no value for this key.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#remove(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#/:" data-isabs="false">
      <a id="/:[B](B)((B, GridCacheEntry[K, V]) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $div$colon">/:</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (B, <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.GenTraversableOnce#/:\" data-isabs="false">
      <a id="/:\[A1<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](A1)((A1, A1) ⇒ A1):A1"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $div$colon$bslash">/:\</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="z">z: A1</span>)</span><span class="params">(<span name="op">op: (A1, A1) ⇒ A1</span>)</span><span class="result">: A1</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#:\" data-isabs="false">
      <a id=":\[B](B)((GridCacheEntry[K, V], B) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $colon$bslash">:\</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], B) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#addString" data-isabs="false">
      <a id="addString(StringBuilder):StringBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">addString</span><span class="params">(<span name="b">b: StringBuilder</span>)</span><span class="result">: StringBuilder</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#addString" data-isabs="false">
      <a id="addString(StringBuilder,String):StringBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">addString</span><span class="params">(<span name="b">b: StringBuilder</span>, <span name="sep">sep: String</span>)</span><span class="result">: StringBuilder</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#addString" data-isabs="false">
      <a id="addString(StringBuilder,String,String,String):StringBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">addString</span><span class="params">(<span name="b">b: StringBuilder</span>, <span name="start">start: String</span>, <span name="sep">sep: String</span>, <span name="end">end: String</span>)</span><span class="result">: StringBuilder</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#aggregate" data-isabs="false">
      <a id="aggregate[B](B)((B, GridCacheEntry[K, V]) ⇒ B,(B, B) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">aggregate</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="seqop">seqop: (B, <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ B</span>, <span name="combop">combop: (B, B) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#apply" data-isabs="false">
      <a id="apply(K):V"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="k">k: K</span>)</span><span class="result">: V</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Retrieves value mapped to the specified key from cache.</p><div class="fullcomment"><div class="comment cmt"><p>Retrieves value mapped to the specified key from cache. The return value of <code>null</code>
means entry did not pass the provided filter or cache has no mapping for the key.
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key to retrieve the value for.</p></dd><dt>returns</dt><dd class="cmt"><p>Value for the given key.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#canEqual" data-isabs="false">
      <a id="canEqual(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">canEqual</span><span class="params">(<span name="that">that: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → Equals</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#collect" data-isabs="false">
      <a id="collect[B, That](PartialFunction[GridCacheEntry[K, V], B])(CanBuildFrom[Iterable[GridCacheEntry[K, V]], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collect</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="pf">pf: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#collectFirst" data-isabs="false">
      <a id="collectFirst[B](PartialFunction[GridCacheEntry[K, V], B]):Option[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectFirst</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="pf">pf: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], B]</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.Iterable#companion" data-isabs="false">
      <a id="companion:GenericCompanion[Iterable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">companion</span><span class="result">: <span name="scala.collection.generic.GenericCompanion" class="extype">GenericCompanion</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Iterable → GenIterable → Traversable → GenTraversable → GenericTraversableTemplate</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#copyToArray" data-isabs="false">
      <a id="copyToArray[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](Array[B],Int,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copyToArray</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="xs">xs: <span name="scala.Array" class="extype">Array</span>[B]</span>, <span name="start">start: <span name="scala.Int" class="extype">Int</span></span>, <span name="len">len: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#copyToArray" data-isabs="false">
      <a id="copyToArray[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](Array[B]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copyToArray</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="xs">xs: <span name="scala.Array" class="extype">Array</span>[B]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#copyToArray" data-isabs="false">
      <a id="copyToArray[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](Array[B],Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copyToArray</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="xs">xs: <span name="scala.Array" class="extype">Array</span>[B]</span>, <span name="start">start: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#copyToBuffer" data-isabs="false">
      <a id="copyToBuffer[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](Buffer[B]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copyToBuffer</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="dest">dest: <span name="scala.collection.mutable.Buffer" class="extype">Buffer</span>[B]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#count" data-isabs="false">
      <a id="count((GridCacheEntry[K, V]) ⇒ Boolean):Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">count</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#drop" data-isabs="false">
      <a id="drop(Int):Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">drop</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#dropRight" data-isabs="false">
      <a id="dropRight(Int):Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropRight</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#dropWhile" data-isabs="false">
      <a id="dropWhile((GridCacheEntry[K, V]) ⇒ Boolean):Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropWhile</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#exists" data-isabs="false">
      <a id="exists((GridCacheEntry[K, V]) ⇒ Boolean):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">exists</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#filter" data-isabs="false">
      <a id="filter((GridCacheEntry[K, V]) ⇒ Boolean):Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#filterNot" data-isabs="false">
      <a id="filterNot((GridCacheEntry[K, V]) ⇒ Boolean):Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filterNot</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#find" data-isabs="false">
      <a id="find((GridCacheEntry[K, V]) ⇒ Boolean):Option[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">find</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#flatMap" data-isabs="false">
      <a id="flatMap[B, That]((GridCacheEntry[K, V]) ⇒ GenTraversableOnce[B])(CanBuildFrom[Iterable[GridCacheEntry[K, V]], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.collection.GenTraversableOnce" class="extype">GenTraversableOnce</span>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike → FilterMonadic</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#fold" data-isabs="false">
      <a id="fold[A1<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](A1)((A1, A1) ⇒ A1):A1"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fold</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="z">z: A1</span>)</span><span class="params">(<span name="op">op: (A1, A1) ⇒ A1</span>)</span><span class="result">: A1</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#foldLeft" data-isabs="false">
      <a id="foldLeft[B](B)((B, GridCacheEntry[K, V]) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldLeft</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (B, <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#foldRight" data-isabs="false">
      <a id="foldRight[B](B)((GridCacheEntry[K, V], B) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldRight</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], B) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#forall" data-isabs="false">
      <a id="forall((GridCacheEntry[K, V]) ⇒ Boolean):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">forall</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#foreach" data-isabs="false">
      <a id="foreach[U]((GridCacheEntry[K, V]) ⇒ U):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foreach</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ U</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableLike → TraversableOnce → GenTraversableOnce → FilterMonadic</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.generic.GenericTraversableTemplate#genericBuilder" data-isabs="false">
      <a id="genericBuilder[B]:Builder[B, Iterable[B]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">genericBuilder</span><span class="tparams">[<span name="B">B</span>]</span><span class="result">: <span name="scala.collection.mutable.Builder" class="extype">Builder</span>[B, <span name="scala.collection.Iterable" class="extype">Iterable</span>[B]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenericTraversableTemplate</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#getOrElse" data-isabs="false">
      <a id="getOrElse(K,⇒ V):V"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getOrElse</span><span class="params">(<span name="k">k: K</span>, <span name="default">default: ⇒ V</span>)</span><span class="result">: V</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the value associated with a key, or a default value if the key is not contained in the map.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the value associated with a key, or a default value if the key is not contained in the map.
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>The key.</p></dd><dt class="param">default</dt><dd class="cmt"><p>A computation that yields a default value in case key is not in cache.</p></dd><dt>returns</dt><dd class="cmt"><p>The cache value associated with <code>key</code> if it exists, otherwise the result
     of the <code>default</code> computation.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#groupBy" data-isabs="false">
      <a id="groupBy[K]((GridCacheEntry[K, V]) ⇒ K):Map[K, Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">groupBy</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ K</span>)</span><span class="result">: <span name="scala.collection.immutable.Map" class="extype">Map</span>[K, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#grouped" data-isabs="false">
      <a id="grouped(Int):Iterator[Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">grouped</span><span class="params">(<span name="size">size: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2Text" data-isabs="false">
      <a id="h2Text(String)(Manifest[V]):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2Text</span><span class="params">(<span name="clause">clause: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2Text" data-isabs="false">
      <a id="h2Text(Class[_ <span class='angle_bracket'>&lt;</span>: V],String):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2Text</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2Text" data-isabs="false">
      <a id="h2Text(GridProjection,String)(Manifest[V]):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2Text</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2Text" data-isabs="false">
      <a id="h2Text(GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2Text</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextReduce" data-isabs="false">
      <a id="h2TextReduce[R](String,(Iterable[(K, V)]) ⇒ R)(Manifest[V]):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextReduce" data-isabs="false">
      <a id="h2TextReduce[R](Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextReduce" data-isabs="false">
      <a id="h2TextReduce[R](GridProjection,String,(Iterable[(K, V)]) ⇒ R)(Manifest[V]):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextReduce" data-isabs="false">
      <a id="h2TextReduce[R](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextReduce" data-isabs="false">
      <a id="h2TextReduce[R1, R2](String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2)(Manifest[V]):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextReduce" data-isabs="false">
      <a id="h2TextReduce[R1, R2](Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextReduce" data-isabs="false">
      <a id="h2TextReduce[R1, R2](GridProjection,String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2)(Manifest[V]):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextReduce" data-isabs="false">
      <a id="h2TextReduce[R1, R2](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextTransform" data-isabs="false">
      <a id="h2TextTransform[T](String,(V) ⇒ T)(Manifest[V]):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> transform query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> transform query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextTransform" data-isabs="false">
      <a id="h2TextTransform[T](Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(V) ⇒ T):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> transform query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> transform query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextTransform" data-isabs="false">
      <a id="h2TextTransform[T](GridProjection,String,(V) ⇒ T)(Manifest[V]):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> transform query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> transform query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#h2TextTransform" data-isabs="false">
      <a id="h2TextTransform[T](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(V) ⇒ T):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">h2TextTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>H2TEXT</code> transform query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>H2TEXT</code> transform query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query H2 text clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#hasDefiniteSize" data-isabs="false">
      <a id="hasDefiniteSize:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hasDefiniteSize</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#head" data-isabs="false">
      <a id="head:GridCacheEntry[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">head</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike → TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#headOption" data-isabs="false">
      <a id="headOption:Option[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">headOption</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#impl" data-isabs="false">
      <a id="impl:GridCacheProjection[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">var</span>
      </span>
      <span class="symbol">
        <span class="name">impl</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheProjection" class="extype">GridCacheProjection</span>[K, V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#init" data-isabs="false">
      <a id="init:Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">init</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#inits" data-isabs="false">
      <a id="inits:Iterator[Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inits</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#isEmpty" data-isabs="false">
      <a id="isEmpty:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isEmpty</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike → TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.GenTraversableLike#isTraversableAgain" data-isabs="false">
      <a id="isTraversableAgain:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isTraversableAgain</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenTraversableLike → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#iterator" data-isabs="false">
      <a id="iterator:Iterator[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">iterator</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets iterator for cache entries.</p><div class="fullcomment"><div class="comment cmt"><p>Gets iterator for cache entries.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp" class="extype" href="">ScalarCacheProjectionPimp</a> → IterableLike → GenIterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#last" data-isabs="false">
      <a id="last:GridCacheEntry[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">last</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#lastOption" data-isabs="false">
      <a id="lastOption:Option[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lastOption</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#lucene" data-isabs="false">
      <a id="lucene(String)(Manifest[V]):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lucene</span><span class="params">(<span name="clause">clause: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#lucene" data-isabs="false">
      <a id="lucene(Class[_ <span class='angle_bracket'>&lt;</span>: V],String):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lucene</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#lucene" data-isabs="false">
      <a id="lucene(GridProjection,String)(Manifest[V]):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lucene</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#lucene" data-isabs="false">
      <a id="lucene(GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lucene</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneReduce" data-isabs="false">
      <a id="luceneReduce[R](String,(Iterable[(K, V)]) ⇒ R)(Manifest[V]):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneReduce" data-isabs="false">
      <a id="luceneReduce[R](Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneReduce" data-isabs="false">
      <a id="luceneReduce[R](GridProjection,String,(Iterable[(K, V)]) ⇒ R)(Manifest[V]):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneReduce" data-isabs="false">
      <a id="luceneReduce[R](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneReduce" data-isabs="false">
      <a id="luceneReduce[R1, R2](String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2)(Manifest[V]):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneReduce" data-isabs="false">
      <a id="luceneReduce[R1, R2](Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneReduce" data-isabs="false">
      <a id="luceneReduce[R1, R2](GridProjection,String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2)(Manifest[V]):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneReduce" data-isabs="false">
      <a id="luceneReduce[R1, R2](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneTransform" data-isabs="false">
      <a id="luceneTransform[T](String,(V) ⇒ T)(Manifest[V]):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> transform query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> transform query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneTransform" data-isabs="false">
      <a id="luceneTransform[T](Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(V) ⇒ T):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> transform query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> transform query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneTransform" data-isabs="false">
      <a id="luceneTransform[T](GridProjection,String,(V) ⇒ T)(Manifest[V]):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> transform query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> transform query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#luceneTransform" data-isabs="false">
      <a id="luceneTransform[T](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(V) ⇒ T):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">luceneTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>LUCENE</code> transform query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>LUCENE</code> transform query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query Lucene clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#map" data-isabs="false">
      <a id="map[B, That]((GridCacheEntry[K, V]) ⇒ B)(CanBuildFrom[Iterable[GridCacheEntry[K, V]], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike → FilterMonadic</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#max" data-isabs="false">
      <a id="max[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](Ordering[B]):GridCacheEntry[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">max</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="cmp">cmp: Ordering[B]</span>)</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#maxBy" data-isabs="false">
      <a id="maxBy[B]((GridCacheEntry[K, V]) ⇒ B)(Ordering[B]):GridCacheEntry[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">maxBy</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="cmp">cmp: Ordering[B]</span>)</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#min" data-isabs="false">
      <a id="min[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](Ordering[B]):GridCacheEntry[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">min</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="cmp">cmp: Ordering[B]</span>)</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#minBy" data-isabs="false">
      <a id="minBy[B]((GridCacheEntry[K, V]) ⇒ B)(Ordering[B]):GridCacheEntry[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">minBy</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="cmp">cmp: Ordering[B]</span>)</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#mkString" data-isabs="false">
      <a id="mkString:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mkString</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#mkString" data-isabs="false">
      <a id="mkString(String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mkString</span><span class="params">(<span name="sep">sep: String</span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#mkString" data-isabs="false">
      <a id="mkString(String,String,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mkString</span><span class="params">(<span name="start">start: String</span>, <span name="sep">sep: String</span>, <span name="end">end: String</span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="prt" name="scala.collection.generic.GenericTraversableTemplate#newBuilder" data-isabs="false">
      <a id="newBuilder:Builder[GridCacheEntry[K, V], Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">newBuilder</span><span class="result">: <span name="scala.collection.mutable.Builder" class="extype">Builder</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[this] </dd><dt>Definition Classes</dt><dd>GenericTraversableTemplate → HasNewBuilder</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#nonEmpty" data-isabs="false">
      <a id="nonEmpty:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nonEmpty</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#opt" data-isabs="false">
      <a id="opt(K,EntryPred*):Option[V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="params">(<span name="k">k: K</span>, <span name="p">p: EntryPred*</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Retrieves value mapped to the specified key from cache as an option.</p><div class="fullcomment"><div class="comment cmt"><p>Retrieves value mapped to the specified key from cache as an option. The return value
of <code>null</code> means entry did not pass the provided filter or cache has no mapping for the key.
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key to retrieve the value for.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Filter to check prior to getting the value. Note that filter check
     together with getting the value is an atomic operation.</p></dd><dt>returns</dt><dd class="cmt"><p>Value for the given key.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection.get(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.Parallelizable#par" data-isabs="false">
      <a id="par:ParIterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">par</span><span class="result">: <span name="scala.collection.parallel.ParIterable" class="extype">ParIterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parallelizable</dd></dl></div>
    </li><li visbl="prt" name="scala.collection.TraversableLike#parCombiner" data-isabs="false">
      <a id="parCombiner:Combiner[GridCacheEntry[K, V], ParIterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parCombiner</span><span class="result">: <span name="scala.collection.parallel.Combiner" class="extype">Combiner</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.parallel.ParIterable" class="extype">ParIterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[this] </dd><dt>Definition Classes</dt><dd>TraversableLike → Parallelizable</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#partition" data-isabs="false">
      <a id="partition((GridCacheEntry[K, V]) ⇒ Boolean):(Iterable[GridCacheEntry[K, V]], Iterable[GridCacheEntry[K, V]])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">partition</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]])</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#product" data-isabs="false">
      <a id="product[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](Numeric[B]):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">product</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: Numeric[B]</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#put$" data-isabs="false">
      <a id="put$((K, V),EntryPred*):V"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">put$</span><span class="params">(<span name="kv">kv: (K, V)</span>, <span name="p">p: EntryPred*</span>)</span><span class="result">: V</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores given key-value pair in cache.</p><div class="fullcomment"><div class="comment cmt"><p>Stores given key-value pair in cache. If filters are provided, then entries will
be stored in cache only if they pass the filter. Note that filter check is atomic,
so value stored in cache is guaranteed to be consistent with the filters.</p><p>If write-through is enabled, the stored value will be persisted to <code>GridCacheStore</code>
via <code>GridCacheStore#put(String, GridCacheTx, Object, Object)</code> method.</p><h5>Transactions</h5><p>This method is transactional and will enlist the entry into ongoing transaction
if there is one.</p><h5>Cache Flags</h5><p>This method is not available if any of the following flags are set on projection:
<code>GridCacheFlag#LOCAL</code>, <code>GridCacheFlag#READ</code>.
</p></div><dl class="paramcmts block"><dt class="param">kv</dt><dd class="cmt"><p>Key-Value pair to store in cache.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional filter to check prior to putting value in cache. Note
     that filter check is atomic with put operation.</p></dd><dt>returns</dt><dd class="cmt"><p>Previous value associated with specified key, or <code>null</code>
     if entry did not pass the filter, or if there was no mapping for the key in swap
     or in persistent storage.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#put(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#putAll$" data-isabs="false">
      <a id="putAll$(Seq[(K, V)]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">putAll$</span><span class="params">(<span name="kvs">kvs: <span name="scala.collection.Seq" class="extype">Seq</span>[(K, V)]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores given key-value pairs from the sequence in cache.</p><div class="fullcomment"><div class="comment cmt"><p>Stores given key-value pairs from the sequence in cache.</p><p>If write-through is enabled, the stored values will be persisted to <code>GridCacheStore</code>
via <code>GridCacheStore#putAll(String, GridCacheTx, Map)</code> method.</p><h5>Transactions</h5><p>This method is transactional and will enlist the entry into ongoing transaction
if there is one.</p><h5>Cache Flags</h5><p>This method is not available if any of the following flags are set on projection:
<code>GridCacheFlag#LOCAL</code>, <code>GridCacheFlag#READ</code>.
</p></div><dl class="paramcmts block"><dt class="param">kvs</dt><dd class="cmt"><p>Key-value pairs to store in cache. If <code>null</code> this function is no-op.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#putAll(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#putAll$" data-isabs="false">
      <a id="putAll$((K, V),(K, V),(K, V)*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">putAll$</span><span class="params">(<span name="kv1">kv1: (K, V)</span>, <span name="kv2">kv2: (K, V)</span>, <span name="kvs">kvs: (K, V)*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores given key-value pairs in cache.</p><div class="fullcomment"><div class="comment cmt"><p>Stores given key-value pairs in cache.</p><p>If write-through is enabled, the stored values will be persisted to <code>GridCacheStore</code>
via <code>GridCacheStore#putAll(String, GridCacheTx, Map)</code> method.</p><h5>Transactions</h5><p>This method is transactional and will enlist the entry into ongoing transaction
if there is one.</p><h5>Cache Flags</h5><p>This method is not available if any of the following flags are set on projection:
<code>GridCacheFlag#LOCAL</code>, <code>GridCacheFlag#READ</code>.
</p></div><dl class="paramcmts block"><dt class="param">kv1</dt><dd class="cmt"><p>Key-value pair to store in cache.</p></dd><dt class="param">kv2</dt><dd class="cmt"><p>Key-value pair to store in cache.</p></dd><dt class="param">kvs</dt><dd class="cmt"><p>Optional key-value pairs to store in cache.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#putAll(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#putOpt$" data-isabs="false">
      <a id="putOpt$((K, V),EntryPred*):Option[V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">putOpt$</span><span class="params">(<span name="kv">kv: (K, V)</span>, <span name="p">p: EntryPred*</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores given key-value pair in cache.</p><div class="fullcomment"><div class="comment cmt"><p>Stores given key-value pair in cache. If filters are provided, then entries will
be stored in cache only if they pass the filter. Note that filter check is atomic,
so value stored in cache is guaranteed to be consistent with the filters.</p><p>If write-through is enabled, the stored value will be persisted to <code>GridCacheStore</code>
via <code>GridCacheStore#put(String, GridCacheTx, Object, Object)</code> method.</p><h5>Transactions</h5><p>This method is transactional and will enlist the entry into ongoing transaction
if there is one.</p><h5>Cache Flags</h5><p>This method is not available if any of the following flags are set on projection:
<code>GridCacheFlag#LOCAL</code>, <code>GridCacheFlag#READ</code>.
</p></div><dl class="paramcmts block"><dt class="param">kv</dt><dd class="cmt"><p>Key-Value pair to store in cache.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional filter to check prior to putting value in cache. Note
     that filter check is atomic with put operation.</p></dd><dt>returns</dt><dd class="cmt"><p>Previous value associated with specified key as an option.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#put(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#putx$" data-isabs="false">
      <a id="putx$((K, V),EntryPred*):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">putx$</span><span class="params">(<span name="kv">kv: (K, V)</span>, <span name="p">p: EntryPred*</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores given key-value pair in cache.</p><div class="fullcomment"><div class="comment cmt"><p>Stores given key-value pair in cache. If filters are provided, then entries will
be stored in cache only if they pass the filter. Note that filter check is atomic,
so value stored in cache is guaranteed to be consistent with the filters.</p><p>If write-through is enabled, the stored value will be persisted to <code>GridCacheStore</code>
via <code>GridCacheStore#put(String, GridCacheTx, Object, Object)</code> method.</p><h5>Transactions</h5><p>This method is transactional and will enlist the entry into ongoing transaction
if there is one.</p><h5>Cache Flags</h5><p>This method is not available if any of the following flags are set on projection:
<code>GridCacheFlag#LOCAL</code>, <code>GridCacheFlag#READ</code>.
</p></div><dl class="paramcmts block"><dt class="param">kv</dt><dd class="cmt"><p>Key-Value pair to store in cache.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional filter to check prior to putting value in cache. Note
     that filter check is atomic with put operation.</p></dd><dt>returns</dt><dd class="cmt"><p><code>True</code> if value was stored in cache, <code>false</code> otherwise.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#putx(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#reduce" data-isabs="false">
      <a id="reduce[A1<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]]((A1, A1) ⇒ A1):A1"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduce</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="op">op: (A1, A1) ⇒ A1</span>)</span><span class="result">: A1</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#reduceLeft" data-isabs="false">
      <a id="reduceLeft[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]]((B, GridCacheEntry[K, V]) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceLeft</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="op">op: (B, <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#reduceLeftOption" data-isabs="false">
      <a id="reduceLeftOption[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]]((B, GridCacheEntry[K, V]) ⇒ B):Option[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceLeftOption</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="op">op: (B, <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ B</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#reduceOption" data-isabs="false">
      <a id="reduceOption[A1<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]]((A1, A1) ⇒ A1):Option[A1]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceOption</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="op">op: (A1, A1) ⇒ A1</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[A1]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#reduceRight" data-isabs="false">
      <a id="reduceRight[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]]((GridCacheEntry[K, V], B) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceRight</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="op">op: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], B) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#reduceRightOption" data-isabs="false">
      <a id="reduceRightOption[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]]((GridCacheEntry[K, V], B) ⇒ B):Option[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceRightOption</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="op">op: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], B) ⇒ B</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#remove$" data-isabs="false">
      <a id="remove$(K,EntryPred*):V"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">remove$</span><span class="params">(<span name="k">k: K</span>, <span name="p">p: EntryPred*</span>)</span><span class="result">: V</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes given key mapping from cache.</p><div class="fullcomment"><div class="comment cmt"><p>Removes given key mapping from cache. If cache previously contained value for the given key,
then this value is returned. Otherwise, in case of <code>GridCacheMode#REPLICATED</code> caches,
the value will be loaded from swap and, if it's not there, and read-through is allowed,
from the underlying <code>GridCacheStore</code> storage. In case of <code>GridCacheMode#PARTITIONED</code>
caches, the value will be loaded from the primary node, which in its turn may load the value
from the swap storage, and consecutively, if it's not in swap and read-through is allowed,
from the underlying persistent storage. If value has to be loaded from persistent
storage, <code>GridCacheStore#load(String, GridCacheTx, Object)</code> method will be used.</p><p>If the returned value is not needed, method <code>removex$(...)</code> should
always be used instead of this one to avoid the overhead associated with returning of the
previous value.</p><p>If write-through is enabled, the value will be removed from 'GridCacheStore'
via <code>GridCacheStore#remove(String, GridCacheTx, Object)</code> method.</p><h5>Transactions</h5><p>This method is transactional and will enlist the entry into ongoing transaction
if there is one.</p><h5>Cache Flags</h5><p>This method is not available if any of the following flags are set on projection:
<code>GridCacheFlag#LOCAL</code>, <code>GridCacheFlag#READ</code>.
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key whose mapping is to be removed from cache.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional filters to check prior to removing value form cache. Note
     that filter is checked atomically together with remove operation.</p></dd><dt>returns</dt><dd class="cmt"><p>Previous value associated with specified key, or <code>null</code>
     if there was no value for this key.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#remove(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#removeAll$" data-isabs="false">
      <a id="removeAll$(K,K,K*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">removeAll$</span><span class="params">(<span name="k1">k1: K</span>, <span name="k2">k2: K</span>, <span name="ks">ks: K*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes given key mappings from cache.</p><div class="fullcomment"><div class="comment cmt"><p>Removes given key mappings from cache.</p><p>If write-through is enabled, the values will be removed from <code>GridCacheStore</code>
via <code>GridCacheStore#removeAll(String, GridCacheTx, Collection)</code> method.</p><h5>Transactions</h5><p>This method is transactional and will enlist the entry into ongoing transaction
if there is one.</p><h5>Cache Flags</h5><p>This method is not available if any of the following flags are set on projection:
<code>GridCacheFlag#LOCAL</code>, <code>GridCacheFlag#READ</code>.
</p></div><dl class="paramcmts block"><dt class="param">k1</dt><dd class="cmt"><p>1st key to remove.</p></dd><dt class="param">k2</dt><dd class="cmt"><p>2nd key to remove.</p></dd><dt class="param">ks</dt><dd class="cmt"><p>Optional sequence of additional keys to remove.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#removeAll(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#removeAll$" data-isabs="false">
      <a id="removeAll$(Seq[K]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">removeAll$</span><span class="params">(<span name="ks">ks: <span name="scala.collection.Seq" class="extype">Seq</span>[K]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes given key mappings from cache.</p><div class="fullcomment"><div class="comment cmt"><p>Removes given key mappings from cache.</p><p>If write-through is enabled, the values will be removed from <code>GridCacheStore</code>
via <code>GridCacheStore#removeAll(String, GridCacheTx, Collection)</code> method.</p><h5>Transactions</h5><p>This method is transactional and will enlist the entry into ongoing transaction
if there is one.</p><h5>Cache Flags</h5><p>This method is not available if any of the following flags are set on projection:
<code>GridCacheFlag#LOCAL</code>, <code>GridCacheFlag#READ</code>.
</p></div><dl class="paramcmts block"><dt class="param">ks</dt><dd class="cmt"><p>Sequence of additional keys to remove. If <code>null</code> - this function is no-op.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#removeAll(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#removeOpt$" data-isabs="false">
      <a id="removeOpt$(K,EntryPred*):Option[V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">removeOpt$</span><span class="params">(<span name="k">k: K</span>, <span name="p">p: EntryPred*</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes given key mapping from cache.</p><div class="fullcomment"><div class="comment cmt"><p>Removes given key mapping from cache. If cache previously contained value for the given key,
then this value is returned. Otherwise, in case of <code>GridCacheMode#REPLICATED</code> caches,
the value will be loaded from swap and, if it's not there, and read-through is allowed,
from the underlying <code>GridCacheStore</code> storage. In case of <code>GridCacheMode#PARTITIONED</code>
caches, the value will be loaded from the primary node, which in its turn may load the value
from the swap storage, and consecutively, if it's not in swap and read-through is allowed,
from the underlying persistent storage. If value has to be loaded from persistent
storage, <code>GridCacheStore#load(String, GridCacheTx, Object)</code> method will be used.</p><p>If the returned value is not needed, method <code>removex$(...)</code> should
always be used instead of this one to avoid the overhead associated with returning of the
previous value.</p><p>If write-through is enabled, the value will be removed from 'GridCacheStore'
via <code>GridCacheStore#remove(String, GridCacheTx, Object)</code> method.</p><h5>Transactions</h5><p>This method is transactional and will enlist the entry into ongoing transaction
if there is one.</p><h5>Cache Flags</h5><p>This method is not available if any of the following flags are set on projection:
<code>GridCacheFlag#LOCAL</code>, <code>GridCacheFlag#READ</code>.
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key whose mapping is to be removed from cache.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional filters to check prior to removing value form cache. Note
     that filter is checked atomically together with remove operation.</p></dd><dt>returns</dt><dd class="cmt"><p>Previous value associated with specified key as an option.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection#remove(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#repr" data-isabs="false">
      <a id="repr:Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repr</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="prt" name="scala.collection.TraversableOnce#reversed" data-isabs="false">
      <a id="reversed:List[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reversed</span><span class="result">: List[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[this] </dd><dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#sameElements" data-isabs="false">
      <a id="sameElements[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](GenIterable[B]):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sameElements</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.GenIterable" class="extype">GenIterable</span>[B]</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scan" data-isabs="false">
      <a id="scan((K) ⇒ Boolean,(V) ⇒ Boolean)(Manifest[V]):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="params">(<span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details..</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scan" data-isabs="false">
      <a id="scan(Class[_ <span class='angle_bracket'>&lt;</span>: V],(K) ⇒ Boolean,(V) ⇒ Boolean):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details..</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scan" data-isabs="false">
      <a id="scan(GridProjection,(K) ⇒ Boolean,(V) ⇒ Boolean)(Manifest[V]):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details..</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scan" data-isabs="false">
      <a id="scan(GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],(K) ⇒ Boolean,(V) ⇒ Boolean):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details..</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#scan" data-isabs="false">
      <a id="scan[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V], That](B)((B, B) ⇒ B)(CanBuildFrom[Iterable[GridCacheEntry[K, V]], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>, <span name="That">That</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (B, B) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="cbf">cbf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#scanLeft" data-isabs="false">
      <a id="scanLeft[B, That](B)((B, GridCacheEntry[K, V]) ⇒ B)(CanBuildFrom[Iterable[GridCacheEntry[K, V]], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanLeft</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (B, <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanReduce" data-isabs="false">
      <a id="scanReduce[R]((K) ⇒ Boolean,(V) ⇒ Boolean,(Iterable[(K, V)]) ⇒ R)(Manifest[V]):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanReduce" data-isabs="false">
      <a id="scanReduce[R](Class[_ <span class='angle_bracket'>&lt;</span>: V],(K) ⇒ Boolean,(V) ⇒ Boolean,(Iterable[(K, V)]) ⇒ R):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanReduce" data-isabs="false">
      <a id="scanReduce[R](GridProjection,(K) ⇒ Boolean,(V) ⇒ Boolean,(Iterable[(K, V)]) ⇒ R)(Manifest[V]):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanReduce" data-isabs="false">
      <a id="scanReduce[R](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],(K) ⇒ Boolean,(V) ⇒ Boolean,(Iterable[(K, V)]) ⇒ R):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanReduce" data-isabs="false">
      <a id="scanReduce[R1, R2]((K) ⇒ Boolean,(V) ⇒ Boolean,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2)(Manifest[V]):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanReduce" data-isabs="false">
      <a id="scanReduce[R1, R2](Class[_ <span class='angle_bracket'>&lt;</span>: V],(K) ⇒ Boolean,(V) ⇒ Boolean,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanReduce" data-isabs="false">
      <a id="scanReduce[R1, R2](GridProjection,(K) ⇒ Boolean,(V) ⇒ Boolean,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2)(Manifest[V]):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanReduce" data-isabs="false">
      <a id="scanReduce[R1, R2](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],(K) ⇒ Boolean,(V) ⇒ Boolean,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#scanRight" data-isabs="false">
      <a id="scanRight[B, That](B)((GridCacheEntry[K, V], B) ⇒ B)(CanBuildFrom[Iterable[GridCacheEntry[K, V]], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanRight</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], B) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd><dt>Annotations</dt><dd>
                <span class="name">@migration</span>
              
        </dd><dt>Migration</dt><dd class="cmt"><p><i>(Changed in version 2.9.0)</i> The behavior of <code>scanRight</code> has changed. The previous behavior can be reproduced with scanRight.reverse.</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanTransform" data-isabs="false">
      <a id="scanTransform[T]((K) ⇒ Boolean,(V) ⇒ Boolean,(V) ⇒ T)(Manifest[V]):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> transform query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> transform query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanTransform" data-isabs="false">
      <a id="scanTransform[T](Class[_ <span class='angle_bracket'>&lt;</span>: V],(K) ⇒ Boolean,(V) ⇒ Boolean,(V) ⇒ T):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> transform query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> transform query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanTransform" data-isabs="false">
      <a id="scanTransform[T](GridProjection,(K) ⇒ Boolean,(V) ⇒ Boolean,(V) ⇒ T)(Manifest[V]):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> transform query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> transform query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#scanTransform" data-isabs="false">
      <a id="scanTransform[T](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],(K) ⇒ Boolean,(V) ⇒ Boolean,(V) ⇒ T):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="kp">kp: (K) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="vp">vp: (V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="trans">trans: (V) ⇒ T</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SCAN</code> transform query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SCAN</code> transform query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">kp</dt><dd class="cmt"><p>Key filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">vp</dt><dd class="cmt"><p>Value filter. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.Iterable#seq" data-isabs="false">
      <a id="seq:Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seq</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Iterable → GenIterable → Traversable → GenTraversable → Parallelizable → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#size" data-isabs="false">
      <a id="size:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">size</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#slice" data-isabs="false">
      <a id="slice(Int,Int):Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">slice</span><span class="params">(<span name="from">from: <span name="scala.Int" class="extype">Int</span></span>, <span name="until">until: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#sliding" data-isabs="false">
      <a id="sliding[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](Int,Int):Iterator[Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sliding</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="size">size: <span name="scala.Int" class="extype">Int</span></span>, <span name="step">step: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#sliding" data-isabs="false">
      <a id="sliding[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](Int):Iterator[Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sliding</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span name="size">size: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#span" data-isabs="false">
      <a id="span((GridCacheEntry[K, V]) ⇒ Boolean):(Iterable[GridCacheEntry[K, V]], Iterable[GridCacheEntry[K, V]])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">span</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]])</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#splitAt" data-isabs="false">
      <a id="splitAt(Int):(Iterable[GridCacheEntry[K, V]], Iterable[GridCacheEntry[K, V]])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">splitAt</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]])</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sql" data-isabs="false">
      <a id="sql(String,Any*)(Manifest[V]):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sql</span><span class="params">(<span name="clause">clause: String</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sql" data-isabs="false">
      <a id="sql(Class[_ <span class='angle_bracket'>&lt;</span>: V],String,Any*):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sql</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sql" data-isabs="false">
      <a id="sql(GridProjection,String,Any*)(Manifest[V]):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sql</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sql" data-isabs="false">
      <a id="sql(GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String,Any*):Iterable[(K, V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sql</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlReduce" data-isabs="false">
      <a id="sqlReduce[R](String,(Iterable[(K, V)]) ⇒ R,Any*)(Manifest[V]):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlReduce" data-isabs="false">
      <a id="sqlReduce[R](Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R,Any*):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlReduce" data-isabs="false">
      <a id="sqlReduce[R](GridProjection,String,(Iterable[(K, V)]) ⇒ R,Any*)(Manifest[V]):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlReduce" data-isabs="false">
      <a id="sqlReduce[R](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R,Any*):Iterable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlReduce</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of reduced values.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlReduce" data-isabs="false">
      <a id="sqlReduce[R1, R2](String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2,Any*)(Manifest[V]):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlReduce" data-isabs="false">
      <a id="sqlReduce[R1, R2](Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2,Any*):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> reduce query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> reduce query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlReduce" data-isabs="false">
      <a id="sqlReduce[R1, R2](GridProjection,String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2,Any*)(Manifest[V]):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlReduce" data-isabs="false">
      <a id="sqlReduce[R1, R2](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(Iterable[(K, V)]) ⇒ R1,(Iterable[R1]) ⇒ R2,Any*):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlReduce</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="rmtRdc">rmtRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, V)]) ⇒ R1</span>, <span name="locRdc">locRdc: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[R1]) ⇒ R2</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> reduce query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> reduce query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">rmtRdc</dt><dd class="cmt"><p>Reduce function that will be called on each remote node.</p></dd><dt class="param">locRdc</dt><dd class="cmt"><p>Reduce function that will be called on local node.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced value.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlTransform" data-isabs="false">
      <a id="sqlTransform[T](String,(V) ⇒ T,Any*)(Manifest[V]):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> transform query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> transform query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlTransform" data-isabs="false">
      <a id="sqlTransform[T](Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(V) ⇒ T,Any*):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> transform query on global projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> transform query on global projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlTransform" data-isabs="false">
      <a id="sqlTransform[T](GridProjection,String,(V) ⇒ T,Any*)(Manifest[V]):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: Manifest[V]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> transform query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> transform query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.</p><p>Note that query value class will be taken implicitly as exact type <code>V</code> of this
cache projection.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#sqlTransform" data-isabs="false">
      <a id="sqlTransform[T](GridProjection,Class[_ <span class='angle_bracket'>&lt;</span>: V],String,(V) ⇒ T,Any*):Iterable[(K, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqlTransform</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="grid">grid: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>, <span name="cls">cls: Class[_ <span class='angle_bracket'>&lt;</span>: V]</span>, <span name="clause">clause: String</span>, <span name="trans">trans: (V) ⇒ T</span>, <span name="args">args: <span name="scala.Any" class="extype">Any</span>*</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[(K, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates and executes ad-hoc <code>SQL</code> transform query on given projection returning its result.</p><div class="fullcomment"><div class="comment cmt"><p>Creates and executes ad-hoc <code>SQL</code> transform query on given projection returning its result.</p><p>Note that if query is executed more than once (potentially with different
arguments) it is more performant to create query via standard mechanism
and execute it multiple times with different arguments. The analogy is
similar to JDBC <code>PreparedStatement</code>.
</p></div><dl class="paramcmts block"><dt class="param">grid</dt><dd class="cmt"><p>Grid projection on which this query will be executed.</p></dd><dt class="param">cls</dt><dd class="cmt"><p>Query values class. Since cache can, in general, contain values of any subtype of <code>V</code>
    query needs to know the exact type it should operate on.</p></dd><dt class="param">clause</dt><dd class="cmt"><p>Query SQL clause. See <code>GridCacheQuery</code> for more details.</p></dd><dt class="param">trans</dt><dd class="cmt"><p>Transform function that will be applied to each returned value.</p></dd><dt class="param">args</dt><dd class="cmt"><p>Optional list of query arguments.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of cache key-value pairs.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#stringPrefix" data-isabs="false">
      <a id="stringPrefix:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">stringPrefix</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#sum" data-isabs="false">
      <a id="sum[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](Numeric[B]):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sum</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: Numeric[B]</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#tail" data-isabs="false">
      <a id="tail:Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tail</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#tails" data-isabs="false">
      <a id="tails:Iterator[Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tails</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#take" data-isabs="false">
      <a id="take(Int):Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">take</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#takeRight" data-isabs="false">
      <a id="takeRight(Int):Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeRight</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#takeWhile" data-isabs="false">
      <a id="takeWhile((GridCacheEntry[K, V]) ⇒ Boolean):Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeWhile</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="prt" name="scala.collection.IterableLike#thisCollection" data-isabs="false">
      <a id="thisCollection:Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">thisCollection</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[this] </dd><dt>Definition Classes</dt><dd>IterableLike → TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toArray" data-isabs="false">
      <a id="toArray[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]](ClassManifest[B]):Array[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toArray</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ClassManifest[B]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toBuffer" data-isabs="false">
      <a id="toBuffer[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]]:Buffer[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toBuffer</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="result">: <span name="scala.collection.mutable.Buffer" class="extype">Buffer</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="prt" name="scala.collection.IterableLike#toCollection" data-isabs="false">
      <a id="toCollection(Iterable[GridCacheEntry[K, V]]):Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toCollection</span><span class="params">(<span name="repr">repr: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[this] </dd><dt>Definition Classes</dt><dd>IterableLike → TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toIndexedSeq" data-isabs="false">
      <a id="toIndexedSeq[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]]:IndexedSeq[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toIndexedSeq</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="result">: <span name="scala.collection.immutable.IndexedSeq" class="extype">IndexedSeq</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#toIterable" data-isabs="false">
      <a id="toIterable:Iterable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toIterable</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#toIterator" data-isabs="false">
      <a id="toIterator:Iterator[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toIterator</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toList" data-isabs="false">
      <a id="toList:List[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toList</span><span class="result">: List[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toMap" data-isabs="false">
      <a id="toMap[T, U](<span class='angle_bracket'>&lt;</span>:<span class='angle_bracket'>&lt;</span>[GridCacheEntry[K, V], (T, U)]):Map[T, U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toMap</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.Predef.<span class='angle_bracket'>&lt;</span>:<span class='angle_bracket'>&lt;</span>" class="extype"><span class='angle_bracket'>&lt;</span>:<span class='angle_bracket'>&lt;</span></span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], (T, U)]</span>)</span><span class="result">: <span name="scala.collection.immutable.Map" class="extype">Map</span>[T, U]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toSeq" data-isabs="false">
      <a id="toSeq:Seq[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toSeq</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toSet" data-isabs="false">
      <a id="toSet[B<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V]]:Set[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toSet</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>]</span><span class="result">: <span name="scala.collection.immutable.Set" class="extype">Set</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#toStream" data-isabs="false">
      <a id="toStream:Stream[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toStream</span><span class="result">: <span name="scala.collection.immutable.Stream" class="extype">Stream</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#toTraversable" data-isabs="false">
      <a id="toTraversable:Traversable[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toTraversable</span><span class="result">: <span name="scala.collection.Traversable" class="extype">Traversable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.generic.GenericTraversableTemplate#transpose" data-isabs="false">
      <a id="transpose[B]((GridCacheEntry[K, V]) ⇒ GenTraversableOnce[B]):Iterable[Iterable[B]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transpose</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="asTraversable">asTraversable: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.collection.GenTraversableOnce" class="extype">GenTraversableOnce</span>[B]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[B]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenericTraversableTemplate</dd><dt>Annotations</dt><dd>
                <span class="name">@migration</span>
              
        </dd><dt>Migration</dt><dd class="cmt"><p><i>(Changed in version 2.9.0)</i> <code>transpose</code> throws an <code>IllegalArgumentException</code> if collections are not uniformly sized.</p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.generic.GenericTraversableTemplate#unzip" data-isabs="false">
      <a id="unzip[A1, A2]((GridCacheEntry[K, V]) ⇒ (A1, A2)):(Iterable[A1], Iterable[A2])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unzip</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="asPair">asPair: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ (A1, A2)</span>)</span><span class="result">: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[A1], <span name="scala.collection.Iterable" class="extype">Iterable</span>[A2])</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenericTraversableTemplate</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.generic.GenericTraversableTemplate#unzip3" data-isabs="false">
      <a id="unzip3[A1, A2, A3]((GridCacheEntry[K, V]) ⇒ (A1, A2, A3)):(Iterable[A1], Iterable[A2], Iterable[A3])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unzip3</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="asTriple">asTriple: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ (A1, A2, A3)</span>)</span><span class="result">: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[A1], <span name="scala.collection.Iterable" class="extype">Iterable</span>[A2], <span name="scala.collection.Iterable" class="extype">Iterable</span>[A3])</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenericTraversableTemplate</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#value" data-isabs="false">
      <a id="value:GridCacheProjection[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">value</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheProjection" class="extype">GridCacheProjection</span>[K, V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp" class="extype" href="">ScalarCacheProjectionPimp</a> → PimpedType</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#view" data-isabs="false">
      <a id="view(Int,Int):IterableView[GridCacheEntry[K, V], Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">view</span><span class="params">(<span name="from">from: <span name="scala.Int" class="extype">Int</span></span>, <span name="until">until: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.IterableView" class="extype">IterableView</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#view" data-isabs="false">
      <a id="view:IterableView[GridCacheEntry[K, V], Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">view</span><span class="result">: <span name="scala.collection.IterableView" class="extype">IterableView</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#viewByEntry" data-isabs="false">
      <a id="viewByEntry(EntryPred*):GridCacheProjection[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">viewByEntry</span><span class="params">(<span name="p">p: EntryPred*</span>)</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheProjection" class="extype">GridCacheProjection</span>[K, V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets cache projection based on given entry filter.</p><div class="fullcomment"><div class="comment cmt"><p>Gets cache projection based on given entry filter. This filter will be simply passed through
to all cache operations on this projection. Unlike <code>viewByKv</code> function, this filter
will <b>not</b> be used for pre-filtering.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Filter to be passed through to all cache operations. If <code>null</code>, then the
     same projection is returned.  If cache operation receives its own filter, then filters
     will be <code>anded</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>Projection based on given filter.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection.projection(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#viewByKv" data-isabs="false">
      <a id="viewByKv((K, V) ⇒ Boolean*):GridCacheProjection[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">viewByKv</span><span class="params">(<span name="p">p: (K, V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span>*</span>)</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheProjection" class="extype">GridCacheProjection</span>[K, V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets cache projection based on given key-value predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Gets cache projection based on given key-value predicate. Whenever makes sense,
this predicate will be used to pre-filter cache operations. If
operation passed pre-filtering, this filter will be passed through
to cache operations as well.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Key-value predicate for this projection. If <code>null</code>, then the
     same projection is returned.</p></dd><dt>returns</dt><dd class="cmt"><p>Projection for given key-value predicate.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection.projection(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp#viewByType" data-isabs="false">
      <a id="viewByType[A, B](Class[A],Class[B]):GridCacheProjection[A, B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">viewByType</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="k">k: Class[A]</span>, <span name="v">v: Class[B]</span>)</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheProjection" class="extype">GridCacheProjection</span>[A, B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets cache projection only for given key and value type.</p><div class="fullcomment"><div class="comment cmt"><p>Gets cache projection only for given key and value type. Only <code>non-null</code> key-value
pairs that have matching key and value pairs will be used in this projection.</p><h5>Cache Flags</h5><p>The resulting projection will have flag <code>GridCacheFlag#STRICT</code> set on it.
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>Key type.</p></dd><dt class="param">v</dt><dd class="cmt"><p>Value type.</p></dd><dt>returns</dt><dd class="cmt"><p>Cache projection for given key and value types.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.cache.GridCacheProjection.projection(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#withFilter" data-isabs="false">
      <a id="withFilter((GridCacheEntry[K, V]) ⇒ Boolean):FilterMonadic[GridCacheEntry[K, V], Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFilter</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.generic.FilterMonadic" class="extype">FilterMonadic</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → FilterMonadic</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#zip" data-isabs="false">
      <a id="zip[A1<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V], B, That](GenIterable[B])(CanBuildFrom[Iterable[GridCacheEntry[K, V]], (A1, B), That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>, <span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.GenIterable" class="extype">GenIterable</span>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], (A1, B), That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#zipAll" data-isabs="false">
      <a id="zipAll[B, A1<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V], That](GenIterable[B],A1,B)(CanBuildFrom[Iterable[GridCacheEntry[K, V]], (A1, B), That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zipAll</span><span class="tparams">[<span name="B">B</span>, <span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.GenIterable" class="extype">GenIterable</span>[B]</span>, <span name="thisElem">thisElem: A1</span>, <span name="thatElem">thatElem: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], (A1, B), That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#zipWithIndex" data-isabs="false">
      <a id="zipWithIndex[A1<span class='angle_bracket'>&gt;</span>:GridCacheEntry[K, V], That](CanBuildFrom[Iterable[GridCacheEntry[K, V]], (A1, Int), That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zipWithIndex</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>, <span name="That">That</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]], (A1, <span name="scala.Int" class="extype">Int</span>), That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike</dd></dl></div>
    </li></ol>
            </div>

        <div class="values members" id="values">
              <h3>Deprecated Value Members</h3>
              <ol><li visbl="pub" name="scala.collection.IterableLike#elements" data-isabs="false">
      <a id="elements:Iterator[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.8.0) use iterator' instead">elements</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.8.0)</i> use <code>iterator' instead</code></p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#first" data-isabs="false">
      <a id="first:GridCacheEntry[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.8.0) use head' instead">first</span><span class="result">: <span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.8.0)</i> use <code>head' instead</code></p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#firstOption" data-isabs="false">
      <a id="firstOption:Option[GridCacheEntry[K, V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.8.0) use headOption' instead">firstOption</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.8.0)</i> use <code>headOption' instead</code></p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#projection" data-isabs="false">
      <a id="projection:IterableView[GridCacheEntry[K, V], Iterable[GridCacheEntry[K, V]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.8.0) use view' instead">projection</span><span class="result">: <span name="scala.collection.IterableView" class="extype">IterableView</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.8.0)</i> use <code>view' instead</code></p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div name="scala.collection.Iterable" class="parent">
              <h3>Inherited from <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</h3>
            </div><div name="scala.collection.IterableLike" class="parent">
              <h3>Inherited from <span name="scala.collection.IterableLike" class="extype">IterableLike</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</h3>
            </div><div name="scala.Equals" class="parent">
              <h3>Inherited from <span name="scala.Equals" class="extype">Equals</span></h3>
            </div><div name="scala.collection.GenIterable" class="parent">
              <h3>Inherited from <span name="scala.collection.GenIterable" class="extype">GenIterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</h3>
            </div><div name="scala.collection.GenIterableLike" class="parent">
              <h3>Inherited from <span name="scala.collection.GenIterableLike" class="extype">GenIterableLike</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</h3>
            </div><div name="scala.collection.Traversable" class="parent">
              <h3>Inherited from <span name="scala.collection.Traversable" class="extype">Traversable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</h3>
            </div><div name="scala.collection.GenTraversable" class="parent">
              <h3>Inherited from <span name="scala.collection.GenTraversable" class="extype">GenTraversable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</h3>
            </div><div name="scala.collection.generic.GenericTraversableTemplate" class="parent">
              <h3>Inherited from <span name="scala.collection.generic.GenericTraversableTemplate" class="extype">GenericTraversableTemplate</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>]</h3>
            </div><div name="scala.collection.TraversableLike" class="parent">
              <h3>Inherited from <span name="scala.collection.TraversableLike" class="extype">TraversableLike</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</h3>
            </div><div name="scala.collection.GenTraversableLike" class="parent">
              <h3>Inherited from <span name="scala.collection.GenTraversableLike" class="extype">GenTraversableLike</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</h3>
            </div><div name="scala.collection.Parallelizable" class="parent">
              <h3>Inherited from <span name="scala.collection.Parallelizable" class="extype">Parallelizable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.parallel.ParIterable" class="extype">ParIterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</h3>
            </div><div name="scala.collection.TraversableOnce" class="parent">
              <h3>Inherited from <span name="scala.collection.TraversableOnce" class="extype">TraversableOnce</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</h3>
            </div><div name="scala.collection.GenTraversableOnce" class="parent">
              <h3>Inherited from <span name="scala.collection.GenTraversableOnce" class="extype">GenTraversableOnce</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]</h3>
            </div><div name="scala.collection.generic.FilterMonadic" class="parent">
              <h3>Inherited from <span name="scala.collection.generic.FilterMonadic" class="extype">FilterMonadic</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</h3>
            </div><div name="scala.collection.generic.HasNewBuilder" class="parent">
              <h3>Inherited from <span name="scala.collection.generic.HasNewBuilder" class="extype">HasNewBuilder</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.cache.GridCacheEntry" class="extype">GridCacheEntry</span>[K, V]]]</h3>
            </div><div name="scalaz.PimpedType" class="parent">
              <h3>Inherited from <span name="scalaz.PimpedType" class="extype">PimpedType</span>[<span name="org.gridgain.grid.cache.GridCacheProjection" class="extype">GridCacheProjection</span>[K, V]]</h3>
            </div><div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    
                
                    <table style="padding: 30px 10px 10px 10px; width: 100%">
                    <tr>
                        <td align="left" valign="center">
                            <nobr>GridGain - Real Time Big Data</nobr>
                            <br>
                            Version: <b>4.0.3</b>, Build: <b>14052012</b>
                            <br>
                            <a target=_blank href="http://www.gridgain.com"><nobr>2012 Copyright &#169; GridGain Systems</nobr></a>
                        </td>
                        <td width="45%">&nbsp;</td>
                        <td align="center" valign="center">
                            <table border="0">
                            <tr>
                                <td>
                                    <nobr>Follow us:&nbsp;&nbsp;</nobr>
                                </td>
                                <td style="padding-right: 5px">
                                    <a target=github class='img_link' href='https://github.com/gridgain/gridgain'>
                                        <img border=0 align=absmiddle src='http://www.gridgain.com/images/github_cat_31x28.gif' alt='Follow GridGain on Github'>
                                    </a>
                                </td>
                                <td style="padding-right: 5px">
                                    <a target=facebook class='img_link' href='http://www.facebook.com/profile.php?id=6458239494'>
                                        <img border=0 align=absmiddle src='http://www.gridgain.com/images/facebook_small.png' alt='Follow GridGain on Facebook'>
                                    </a>
                                </td>
                                <td style="padding-right: 5px">
                                    <a class='img_link' target=meetup href='http://www.meetup.com/GridGain-Bay-Area-Meetup-Group'>
                                        <img border=0 align=absmiddle src='http://www.gridgain.com/images/meetup_logo_small.png' alt='Join GridGain User Group'/>
                                    </a>
                                </td>
                                <td style="padding-right: 5px">
                                    <a class='img_link' target=twitter href='http://www.twitter.com/gridgain'>
                                        <img border=0 align=absmiddle src='http://www.gridgain.com/images/twitter.gif' alt='Follow GridGain on Twitter'/>
                                    </a>
                                </td>
                                <td>
                                    <a class='img_link' target=vimeo href='http://www.vimeo.com/gridgain'>
                                        <img border=0 align=absmiddle src='http://www.gridgain.com/images/vimeo.png' alt='Follow GridGain on Vimeo'/>
                                    </a>
                                </td>
                            </tr>
                            </table>
                        </td>
                        <td width="50%">&nbsp;</td>
                        <td align="right" valign="center">
                            <a class="img-link" target=_blank href="http://www.gridgain.com">
                                <img border="0" src="http://www.gridgain.com/images/logo/logo_small.png">
                            </a>
                        </td>
                    </tr>
                    </table>
                
            <script type='text/javascript'>SyntaxHighlighter.all();dp.SyntaxHighlighter.HighlightAll('code');</script>
</body>

      </html>