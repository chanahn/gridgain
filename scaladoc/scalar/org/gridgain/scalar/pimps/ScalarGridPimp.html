<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>org.gridgain.scalar.pimps.ScalarGridPimp</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../../../lib/template.css" />
      <script type="text/javascript" src="../../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../../lib/tools.tooltip.js"></script>
    
        <link type='text/css' rel='stylesheet' href='http://www.gridgain.com/sh3.0/styles/shCore.css'/>
<link type='text/css' rel='stylesheet' href='http://www.gridgain.com/sh3.0/styles/shThemeMidnight.css'/>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/src/shCore.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/src/shLegacy.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushJava.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushPlain.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushJScript.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushXml.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushScala.js'></script>
<script type='text/javascript' src='http://www.gridgain.com/sh3.0/scripts/shBrushGroovy.js'></script>
</head>

        <body onload="sh_highlightDocument('../lib/', '.min.js');" class="type">
      <div id="definition">
        <a title="Go to companion" href="ScalarGridPimp$.html"><img src="../../../../lib/class_to_object_big.png" /></a>
        <p id="owner"><a name="org" class="extype" href="../../../package.html">org</a>.<a name="org.gridgain" class="extype" href="../../package.html">gridgain</a>.<a name="org.gridgain.scalar" class="extype" href="../package.html">scalar</a>.<a name="org.gridgain.scalar.pimps" class="extype" href="package.html">pimps</a></p>
        <h1><a title="Go to companion" href="ScalarGridPimp$.html">ScalarGridPimp</a></h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">ScalarGridPimp</span><span class="result"> extends <a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a>[<span name="org.gridgain.grid.Grid" class="extype">Grid</span>] with <a name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="extype" href="ScalarTaskThreadContext.html">ScalarTaskThreadContext</a>[<span name="org.gridgain.grid.Grid" class="extype">Grid</span>]</span>
      </span>
      </h4>
      
      <div class="fullcommenttop" id="comment"><div class="comment cmt"><h4>Overview</h4><p>Defines Scalar &quot;pimp&quot; for <code>Grid</code> on Java side.</p><p>Essentially this class extends Java <code>GridProjection</code> interface with Scala specific
API adapters using primarily implicit conversions defined in <code>ScalarConversions</code> object. What
it means is that you can use functions defined in this class on object
of Java <code>GridProjection</code> type. Scala will automatically (implicitly) convert it into
Scalar's pimp and replace the original call with a call on that pimp.</p><p>Note that Scalar provide extensive library of implicit conversion between Java and
Scala GridGain counterparts in <code>ScalarConversions</code> object</p><h4>Suffix '$' In Names</h4><p>Symbol <code>$</code> is used in names when they conflict with the names in the base Java class
that Scala pimp is shadowing or with Java package name that your Scala code is importing.
Instead of giving two different names to the same function we've decided to simply mark
Scala's side method with <code>$</code> suffix.
</p></div><dl class="attributes block"> <dt>Version</dt><dd><p>GridGain 4.0.3 build: 14052012
</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a>[<span name="org.gridgain.grid.Grid" class="extype">Grid</span>], <a name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="extype" href="ScalarTaskThreadContext.html">ScalarTaskThreadContext</a>[<span name="org.gridgain.grid.Grid" class="extype">Grid</span>], <a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], <span name="scala.collection.IterableLike" class="extype">IterableLike</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]], <span name="scala.Equals" class="extype">Equals</span>, <span name="scala.collection.GenIterable" class="extype">GenIterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], <span name="scala.collection.GenIterableLike" class="extype">GenIterableLike</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]], <span name="scala.collection.Traversable" class="extype">Traversable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], <span name="scala.collection.GenTraversable" class="extype">GenTraversable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], <span name="scala.collection.generic.GenericTraversableTemplate" class="extype">GenericTraversableTemplate</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>], <span name="scala.collection.TraversableLike" class="extype">TraversableLike</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]], <span name="scala.collection.GenTraversableLike" class="extype">GenTraversableLike</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]], <span name="scala.collection.Parallelizable" class="extype">Parallelizable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.parallel.ParIterable" class="extype">ParIterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]], <span name="scala.collection.TraversableOnce" class="extype">TraversableOnce</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], <span name="scala.collection.GenTraversableOnce" class="extype">GenTraversableOnce</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], <span name="scala.collection.generic.FilterMonadic" class="extype">FilterMonadic</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]], <span name="scala.collection.generic.HasNewBuilder" class="extype">HasNewBuilder</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]], <span name="scalaz.PimpedType" class="extype">PimpedType</span>[<span name="org.gridgain.grid.Grid" class="extype">Grid</span>], AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div></div>
    

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
            </div>
        <div id="ancestors">
              <span class="filtertype">Inherited</span>
              <ol><li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li></ol>
              <ol id="linearization"><li name="org.gridgain.scalar.pimps.ScalarGridPimp" class="in"><span>ScalarGridPimp</span></li><li name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="in"><span>ScalarProjectionPimp</span></li><li name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="in"><span>ScalarTaskThreadContext</span></li><li name="org.gridgain.scalar.ScalarConversions" class="in"><span>ScalarConversions</span></li><li name="scala.collection.Iterable" class="in"><span>Iterable</span></li><li name="scala.collection.IterableLike" class="in"><span>IterableLike</span></li><li name="scala.Equals" class="in"><span>Equals</span></li><li name="scala.collection.GenIterable" class="in"><span>GenIterable</span></li><li name="scala.collection.GenIterableLike" class="in"><span>GenIterableLike</span></li><li name="scala.collection.Traversable" class="in"><span>Traversable</span></li><li name="scala.collection.GenTraversable" class="in"><span>GenTraversable</span></li><li name="scala.collection.generic.GenericTraversableTemplate" class="in"><span>GenericTraversableTemplate</span></li><li name="scala.collection.TraversableLike" class="in"><span>TraversableLike</span></li><li name="scala.collection.GenTraversableLike" class="in"><span>GenTraversableLike</span></li><li name="scala.collection.Parallelizable" class="in"><span>Parallelizable</span></li><li name="scala.collection.TraversableOnce" class="in"><span>TraversableOnce</span></li><li name="scala.collection.GenTraversableOnce" class="in"><span>GenTraversableOnce</span></li><li name="scala.collection.generic.FilterMonadic" class="in"><span>FilterMonadic</span></li><li name="scala.collection.generic.HasNewBuilder" class="in"><span>HasNewBuilder</span></li><li name="scalaz.PimpedType" class="in"><span>PimpedType</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
            </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div class="members" id="constructors">
              <h3>Instance Constructors</h3>
              <ol><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarGridPimp#this" data-isabs="false">
      <a id="this:ScalarGridPimp"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">ScalarGridPimp</span><span class="params">()</span>
      </span>
      </h4>
      
    </li></ol>
            </div>

        <div class="types members" id="types">
              <h3>Type Members</h3>
              <ol><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#Call" data-isabs="false">
      <a id="Call:() ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Call</span><span class="tparams">[<span name="R">R</span>]</span><span class="result"> = () ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias for '() =<span class='angle_bracket'>&gt;</span> R'.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias for '() =<span class='angle_bracket'>&gt;</span> R'.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#Call1" data-isabs="false">
      <a id="Call1:(E1) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Call1</span><span class="tparams">[<span name="E1">E1</span>, <span name="R">R</span>]</span><span class="result"> = (E1) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias for '(E1) =<span class='angle_bracket'>&gt;</span> R'.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias for '(E1) =<span class='angle_bracket'>&gt;</span> R'.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#Call2" data-isabs="false">
      <a id="Call2:(E1, E2) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Call2</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="R">R</span>]</span><span class="result"> = (E1, E2) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias for '(E1, E2) =<span class='angle_bracket'>&gt;</span> R'.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias for '(E1, E2) =<span class='angle_bracket'>&gt;</span> R'.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#Call3" data-isabs="false">
      <a id="Call3:(E1, E2, E3) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Call3</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="E3">E3</span>, <span name="R">R</span>]</span><span class="result"> = (E1, E2, E3) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias for '(E1, E2, E3) =<span class='angle_bracket'>&gt;</span> R'.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias for '(E1, E2, E3) =<span class='angle_bracket'>&gt;</span> R'.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#NodeFilter" data-isabs="false">
      <a id="NodeFilter:NodeFilter"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">NodeFilter</span><span class="result"> = org.gridgain.grid.lang.GridPredicate[_ <span class='angle_bracket'>&gt;</span>: org.gridgain.grid.GridRichNode]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias for node filter predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias for node filter predicate.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#Pred" data-isabs="false">
      <a id="Pred:() ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Pred</span><span class="result"> = () ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias for '() =<span class='angle_bracket'>&gt;</span> Boolean'.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias for '() =<span class='angle_bracket'>&gt;</span> Boolean'.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#Pred1" data-isabs="false">
      <a id="Pred1:(E1) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Pred1</span><span class="tparams">[<span name="E1">E1</span>]</span><span class="result"> = (E1) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias for '(E1) =<span class='angle_bracket'>&gt;</span> Boolean'.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias for '(E1) =<span class='angle_bracket'>&gt;</span> Boolean'.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#Pred2" data-isabs="false">
      <a id="Pred2:(E1, E2) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Pred2</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>]</span><span class="result"> = (E1, E2) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias for '(E1, E2) =<span class='angle_bracket'>&gt;</span> Boolean'.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias for '(E1, E2) =<span class='angle_bracket'>&gt;</span> Boolean'.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#Pred3" data-isabs="false">
      <a id="Pred3:(E1, E2, E3) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Pred3</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="E3">E3</span>]</span><span class="result"> = (E1, E2, E3) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias for '(E1, E2, E3) =<span class='angle_bracket'>&gt;</span> Boolean'.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias for '(E1, E2, E3) =<span class='angle_bracket'>&gt;</span> Boolean'.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#Run" data-isabs="false">
      <a id="Run:() ⇒ Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Run</span><span class="result"> = () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Type alias for '() =<span class='angle_bracket'>&gt;</span> Unit'.</p><div class="fullcomment"><div class="comment cmt"><p>Type alias for '() =<span class='angle_bracket'>&gt;</span> Unit'.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="prt" name="scala.collection.TraversableLike#Self" data-isabs="false">
      <a id="Self:Self"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Self</span><span class="result"> = <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li></ol>
            </div>

        

        <div class="values members" id="values">
              <h3>Value Members</h3>
              <ol><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#!<span class='angle_bracket'>&lt;</span>" data-isabs="false">
      <a id="!<span class='angle_bracket'>&lt;</span>(Seq[AnyRef],NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$less">!<span class='angle_bracket'>&lt;</span></span><span class="params">(<span name="seq">seq: Seq[AnyRef]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for method <code>send$(...)</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for method <code>send$(...)</code>.
</p></div><dl class="paramcmts block"><dt class="param">seq</dt><dd class="cmt"><p>Optional sequence of objects to send. If empty or <code>null</code> - this
     method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicates. If none provided or <code>null</code> -
     all nodes in the projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.send(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#!<span class='angle_bracket'>&lt;</span>" data-isabs="false">
      <a id="!<span class='angle_bracket'>&lt;</span>(AnyRef,NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$less">!<span class='angle_bracket'>&lt;</span></span><span class="params">(<span name="obj">obj: AnyRef</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for method <code>send$(...)</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for method <code>send$(...)</code>.
</p></div><dl class="paramcmts block"><dt class="param">obj</dt><dd class="cmt"><p>Optional object to send. If <code>null</code> - this method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicates. If none provided or <code>null</code> -
     all nodes in the projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.send(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp##<span class='angle_bracket'>&lt;</span>" data-isabs="false">
      <a id="#<span class='angle_bracket'>&lt;</span>[R](GridClosureCallMode,() ⇒ R,NodeFilter*):Seq[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$less">#<span class='angle_bracket'>&lt;</span></span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: () ⇒ R</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: Seq[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for the same function <code>call$</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for the same function <code>call$</code>.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional closure to call. If <code>null</code> - this method is no-op and returns <code>null</code>.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Sequence of result values from all nodes where given closures were executed
     or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.call(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp##<span class='angle_bracket'>&lt;</span>" data-isabs="false">
      <a id="#<span class='angle_bracket'>&lt;</span>[R](GridClosureCallMode,Seq[() ⇒ R],NodeFilter*):Seq[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$less">#<span class='angle_bracket'>&lt;</span></span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ R]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: Seq[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for the same function <code>call$</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for the same function <code>call$</code>.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this
     method is no-op and returns <code>null</code>.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Sequence of result values from all nodes where given closures were executed
     or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.call(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp##?" data-isabs="false">
      <a id="#?[R](GridClosureCallMode,() ⇒ R,NodeFilter*):GridFuture[Collection[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$qmark">#?</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: () ⇒ R</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[<span name="java.util.Collection" class="extype">Collection</span>[R]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for the same function <code>callAsync$</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for the same function <code>callAsync$</code>.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional closure to call. If <code>null</code> - this method is no-op and finished
     future over <code>null</code> is returned.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Future of Java collection containing result values from all nodes where given
     closures were executed or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.call(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp##?" data-isabs="false">
      <a id="#?[R](GridClosureCallMode,Seq[() ⇒ R],NodeFilter*):GridFuture[Collection[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$qmark">#?</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ R]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[<span name="java.util.Collection" class="extype">Collection</span>[R]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for the same function <code>callAsync$</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for the same function <code>callAsync$</code>.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this method
     is no-op and finished future over <code>null</code> is returned.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Future of Java collection containing result values from all nodes where given
     closures were executed or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.call(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#*<span class='angle_bracket'>&lt;</span>" data-isabs="false">
      <a id="*<span class='angle_bracket'>&lt;</span>(GridClosureCallMode,() ⇒ Unit,NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $times$less">*<span class='angle_bracket'>&lt;</span></span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for the same function <code>run$</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for the same function <code>run$</code>.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional closure to call. If empty or <code>null</code> - this method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.run(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#*<span class='angle_bracket'>&lt;</span>" data-isabs="false">
      <a id="*<span class='angle_bracket'>&lt;</span>(GridClosureCallMode,Seq[() ⇒ Unit],NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $times$less">*<span class='angle_bracket'>&lt;</span></span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ <span name="scala.Unit" class="extype">Unit</span>]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> alias for the same function <code>run$</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> alias for the same function <code>run$</code>.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this
     method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.run(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#*?" data-isabs="false">
      <a id="*?(GridClosureCallMode,() ⇒ Unit,NodeFilter*):org.gridgain.grid.GridFuture[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $times$qmark">*?</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: org.gridgain.grid.GridFuture[_]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for the same function <code>runAsync$</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for the same function <code>runAsync$</code>.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional absolute closure to call. If <code>null</code> - this method
     is no-op and finished future over <code>null</code> will be returned.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.run(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#*?" data-isabs="false">
      <a id="*?(GridClosureCallMode,Seq[() ⇒ Unit],NodeFilter*):org.gridgain.grid.GridFuture[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $times$qmark">*?</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ <span name="scala.Unit" class="extype">Unit</span>]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: org.gridgain.grid.GridFuture[_]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for the same function <code>runAsync$</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for the same function <code>runAsync$</code>.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of absolute closures to call. If empty or <code>null</code> - this method
     is no-op and finished future over <code>null</code> will be returned.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.call(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#++" data-isabs="false">
      <a id="++[B<span class='angle_bracket'>&gt;</span>:GridRichNode, That](GenTraversableOnce[B])(CanBuildFrom[Iterable[GridRichNode], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $plus$plus">++</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.GenTraversableOnce" class="extype">GenTraversableOnce</span>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#++:" data-isabs="false">
      <a id="++:[B<span class='angle_bracket'>&gt;</span>:GridRichNode, That](Traversable[B])(CanBuildFrom[Iterable[GridRichNode], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $plus$plus$colon">++:</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.Traversable" class="extype">Traversable</span>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#++:" data-isabs="false">
      <a id="++:[B<span class='angle_bracket'>&gt;</span>:GridRichNode, That](TraversableOnce[B])(CanBuildFrom[Iterable[GridRichNode], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $plus$plus$colon">++:</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.TraversableOnce" class="extype">TraversableOnce</span>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#/:" data-isabs="false">
      <a id="/:[B](B)((B, GridRichNode) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $div$colon">/:</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (B, <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.GenTraversableOnce#/:\" data-isabs="false">
      <a id="/:\[A1<span class='angle_bracket'>&gt;</span>:GridRichNode](A1)((A1, A1) ⇒ A1):A1"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $div$colon$bslash">/:\</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="z">z: A1</span>)</span><span class="params">(<span name="op">op: (A1, A1) ⇒ A1</span>)</span><span class="result">: A1</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#:\" data-isabs="false">
      <a id=":\[B](B)((GridRichNode, B) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $colon$bslash">:\</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, B) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#@<span class='angle_bracket'>&lt;</span>" data-isabs="false">
      <a id="@<span class='angle_bracket'>&lt;</span>[R1, R2](GridClosureCallMode,Seq[() ⇒ R1],(Seq[R1]) ⇒ R2,NodeFilter*):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $at$less">@<span class='angle_bracket'>&lt;</span></span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ R1]</span>, <span name="r">r: (Seq[R1]) ⇒ R2</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for the same function <code>reduce$</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for the same function <code>reduce$</code>.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">r</dt><dd class="cmt"><p>Optional reduction function. If <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced result or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.reduce(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#@?" data-isabs="false">
      <a id="@?[R1, R2](GridClosureCallMode,Seq[() ⇒ R1],(Seq[R1]) ⇒ R2,NodeFilter*):GridFuture[R2]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $at$qmark">@?</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ R1]</span>, <span name="r">r: (Seq[R1]) ⇒ R2</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[R2]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"><b>Alias</b> for the same function <code>reduceAsync$</code>.</p><div class="fullcomment"><div class="comment cmt"><p><b>Alias</b> for the same function <code>reduceAsync$</code>.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this method
     is no-op and will return finished future over <code>null</code>.</p></dd><dt class="param">r</dt><dd class="cmt"><p>Optional reduction function. If <code>null</code> - this method
     is no-op and will return finished future over <code>null</code>.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Future over the reduced result or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.reduce(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#absClosureDotScala" data-isabs="false">
      <a id="absClosureDotScala(GridAbsClosure):AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> Unit }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">absClosureDotScala</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridAbsClosure" class="extype">GridAbsClosure</span></span>)</span><span class="result">: AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> Unit }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side absolute closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#absClosureXDotScala" data-isabs="false">
      <a id="absClosureXDotScala(GridAbsClosureX):AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> Unit }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">absClosureXDotScala</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridAbsClosureX" class="extype">GridAbsClosureX</span></span>)</span><span class="result">: AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> Unit }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side absolute closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#absPredicateDotScala" data-isabs="false">
      <a id="absPredicateDotScala(GridAbsPredicate):AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> Boolean }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">absPredicateDotScala</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridAbsPredicate" class="extype">GridAbsPredicate</span></span>)</span><span class="result">: AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> Boolean }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Java-side predicate to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#absPredicateXDotScala" data-isabs="false">
      <a id="absPredicateXDotScala(GridAbsPredicateX):AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> Boolean }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">absPredicateXDotScala</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridAbsPredicateX" class="extype">GridAbsPredicateX</span></span>)</span><span class="result">: AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> Boolean }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Java-side predicate to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#addString" data-isabs="false">
      <a id="addString(StringBuilder):StringBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">addString</span><span class="params">(<span name="b">b: StringBuilder</span>)</span><span class="result">: StringBuilder</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#addString" data-isabs="false">
      <a id="addString(StringBuilder,String):StringBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">addString</span><span class="params">(<span name="b">b: StringBuilder</span>, <span name="sep">sep: String</span>)</span><span class="result">: StringBuilder</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#addString" data-isabs="false">
      <a id="addString(StringBuilder,String,String,String):StringBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">addString</span><span class="params">(<span name="b">b: StringBuilder</span>, <span name="start">start: String</span>, <span name="sep">sep: String</span>, <span name="end">end: String</span>)</span><span class="result">: StringBuilder</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#affinityCall$" data-isabs="false">
      <a id="affinityCall$[R](String,Seq[_],() ⇒ R,NodeFilter*):Seq[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">affinityCall$</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="cacheName">cacheName: String</span>, <span name="affKeys">affKeys: Seq[_]</span>, <span name="c">c: () ⇒ R</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: Seq[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes given closure on the nodes where data for provided affinity keys are located.</p><div class="fullcomment"><div class="comment cmt"><p>Executes given closure on the nodes where data for provided affinity keys are located. This
is known as affinity co-location between compute grid (a closure) and in-memory data grid
(value with affinity key). Note that implementation of multiple executions of the same closure will
be wrapped as a single task that splits into multiple <code>job</code>s that will be mapped to nodes
with provided affinity keys.</p><p>This method will block until its execution is complete or an exception is thrown.
All default SPI implementations configured for this grid instance will be
used (i.e. failover, load balancing, collision resolution, etc.).
Note that if you need greater control on any aspects of Java code execution on the grid
you should implement <code>GridTask</code> which will provide you with full control over the execution.</p><p>Notice that <code>Runnable</code> and <code>Callable</code> implementations must support serialization as required
by the configured marshaller. For example, JDK marshaller will require that implementations would
be serializable. Other marshallers, e.g. JBoss marshaller, may not have this limitation. Please consult
with specific marshaller implementation for the details. Note that all closures and predicates in
<code>org.gridgain.grid.lang</code> package are serializable and can be freely used in the distributed
context with all marshallers currently shipped with GridGain.
</p></div><dl class="paramcmts block"><dt class="param">cacheName</dt><dd class="cmt"><p>Name of the cache to use for affinity co-location.</p></dd><dt class="param">affKeys</dt><dd class="cmt"><p>Collection of affinity keys. All dups will be ignored. If <code>null</code>
     or empty - this method is no-op.</p></dd><dt class="param">c</dt><dd class="cmt"><p>Closure to affinity co-located on the node with given affinity key and execute.
     If <code>null</code> - this method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional set of filtering predicates. All predicates must evaluate to <code>true</code> for a
     node to be included. If none provided - all nodes in this projection will be used for topology.</p></dd><dt>returns</dt><dd class="cmt"><p>Collection of closure execution results.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>Exceptions thrown</dt><dd><span class="cmt">GridInterruptedException<p>Subclass of <code>GridException</code> thrown if the wait was interrupted.</p></span><span class="cmt">GridEmptyProjectionException<p>Thrown in case when this projection is empty.
     Note that in case of dynamic projection this method will take a snapshot of all the
     nodes at the time of this call, apply all filtering predicates, if any, and if the
     resulting collection of nodes is empty - the exception will be thrown.</p></span><span class="cmt">GridFutureCancelledException<p>Subclass of <code>GridException</code> thrown if computation was cancelled.
</p></span><span class="cmt">GridException<p>Thrown in case of any error.</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#affinityCallAsync$" data-isabs="false">
      <a id="affinityCallAsync$[R](String,Seq[_],() ⇒ R,NodeFilter*):GridFuture[Collection[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">affinityCallAsync$</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="cacheName">cacheName: String</span>, <span name="affKeys">affKeys: Seq[_]</span>, <span name="c">c: () ⇒ R</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[<span name="java.util.Collection" class="extype">Collection</span>[R]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes given closure on the nodes where data for provided affinity keys are located.</p><div class="fullcomment"><div class="comment cmt"><p>Executes given closure on the nodes where data for provided affinity keys are located. This
is known as affinity co-location between compute grid (a closure) and in-memory data grid
(value with affinity key). Note that implementation of multiple executions of the same closure will
be wrapped as a single task that splits into multiple <code>job</code>s that will be mapped to nodes
with provided affinity keys.</p><p>Unlike its sibling method <code>affinityCall(String, Object, Callable, GridPredicate[])</code> this method does
not block and returns immediately with future. All default SPI implementations
configured for this grid instance will be used (i.e. failover, load balancing, collision resolution, etc.).
Note that if you need greater control on any aspects of Java code execution on the grid
you should implement <code>GridTask</code> which will provide you with full control over the execution.</p><p>Notice that <code>Runnable</code> and <code>Callable</code> implementations must support serialization as required
by the configured marshaller. For example, JDK marshaller will require that implementations would
be serializable. Other marshallers, e.g. JBoss marshaller, may not have this limitation. Please consult
with specific marshaller implementation for the details. Note that all closures and predicates in
<code>org.gridgain.grid.lang</code> package are serializable and can be freely used in the distributed
context with all marshallers currently shipped with GridGain.
</p></div><dl class="paramcmts block"><dt class="param">cacheName</dt><dd class="cmt"><p>Name of the cache to use for affinity co-location.</p></dd><dt class="param">affKeys</dt><dd class="cmt"><p>Collection of affinity keys. All dups will be ignored.
     If <code>null</code> or empty - this method is no-op.</p></dd><dt class="param">c</dt><dd class="cmt"><p>Closure to affinity co-located on the node with given affinity key and execute.
     If <code>null</code> - this method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional set of filtering predicates. All predicates must evaluate to <code>true</code> for a
     node to be included. If none provided - all nodes in this projection will be used for topology.</p></dd><dt>returns</dt><dd class="cmt"><p>Non-cancellable future of closure results. Upon successful execution number of results
     will be equal to number of affinity keys provided.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>Exceptions thrown</dt><dd><span class="cmt">GridInterruptedException<p>Subclass of <code>GridException</code> thrown if the wait was interrupted.</p></span><span class="cmt">GridEmptyProjectionException<p>Thrown in case when this projection is empty.
     Note that in case of dynamic projection this method will take a snapshot of all the
     nodes at the time of this call, apply all filtering predicates, if any, and if the
     resulting collection of nodes is empty - the exception will be thrown.</p></span><span class="cmt">GridFutureCancelledException<p>Subclass of <code>GridException</code> throws if computation was cancelled.
</p></span><span class="cmt">GridException<p>Thrown in case of any error.</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#affinityRun$" data-isabs="false">
      <a id="affinityRun$(String,Seq[_],() ⇒ Unit,NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">affinityRun$</span><span class="params">(<span name="cacheName">cacheName: String</span>, <span name="affKeys">affKeys: Seq[_]</span>, <span name="r">r: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes given closure on the nodes where data for provided affinity keys are located.</p><div class="fullcomment"><div class="comment cmt"><p>Executes given closure on the nodes where data for provided affinity keys are located. This
is known as affinity co-location between compute grid (a closure) and in-memory data grid
(value with affinity key). Note that implementation of multiple executions of the same closure will
be wrapped as a single task that splits into multiple <code>job</code>s that will be mapped to nodes
with provided affinity keys.</p><p>This method will block until its execution is complete or an exception is thrown.
All default SPI implementations configured for this grid instance will be
used (i.e. failover, load balancing, collision resolution, etc.).
Note that if you need greater control on any aspects of Java code execution on the grid
you should implement <code>GridTask</code> which will provide you with full control over the execution.</p><p>Notice that <code>Runnable</code> and <code>Callable</code> implementations must support serialization as required
by the configured marshaller. For example, JDK marshaller will require that implementations would
be serializable. Other marshallers, e.g. JBoss marshaller, may not have this limitation. Please consult
with specific marshaller implementation for the details. Note that all closures and predicates in
<code>org.gridgain.grid.lang</code> package are serializable and can be freely used in the distributed
context with all marshallers currently shipped with GridGain.
</p></div><dl class="paramcmts block"><dt class="param">cacheName</dt><dd class="cmt"><p>Name of the cache to use for affinity co-location.</p></dd><dt class="param">affKeys</dt><dd class="cmt"><p>Collection of affinity keys. All dups will be ignored. If <code>null</code> or empty
     this method is no-op.</p></dd><dt class="param">r</dt><dd class="cmt"><p>Closure to affinity co-located on the node with given affinity key and execute.
     If <code>null</code> - this method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional set of filtering predicates. All predicates must evaluate to <code>true</code> for a
     node to be included. If none provided - all nodes in this projection will be used for topology.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>Exceptions thrown</dt><dd><span class="cmt">GridInterruptedException<p>Subclass of <code>GridException</code> thrown if the wait was interrupted.</p></span><span class="cmt">GridEmptyProjectionException<p>Thrown in case when this projection is empty.
     Note that in case of dynamic projection this method will take a snapshot of all the
     nodes at the time of this call, apply all filtering predicates, if any, and if the
     resulting collection of nodes is empty - the exception will be thrown.</p></span><span class="cmt">GridFutureCancelledException<p>Subclass of <code>GridException</code> thrown if computation was cancelled.
</p></span><span class="cmt">GridException<p>Thrown in case of any error.</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#affinityRunAsync$" data-isabs="false">
      <a id="affinityRunAsync$(String,Seq[_],() ⇒ Unit,NodeFilter*):org.gridgain.grid.GridFuture[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">affinityRunAsync$</span><span class="params">(<span name="cacheName">cacheName: String</span>, <span name="affKeys">affKeys: Seq[_]</span>, <span name="r">r: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: org.gridgain.grid.GridFuture[_]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes given closure on the nodes where data for provided affinity keys are located.</p><div class="fullcomment"><div class="comment cmt"><p>Executes given closure on the nodes where data for provided affinity keys are located. This
is known as affinity co-location between compute grid (a closure) and in-memory data grid
(value with affinity key). Note that implementation of multiple executions of the same closure will
be wrapped as a single task that splits into multiple <code>job</code>s that will be mapped to nodes
with provided affinity keys.</p><p>Unlike its sibling method <code>affinityRun(String, Collection, Runnable, GridPredicate[])</code> this method does
not block and returns immediately with future. All default SPI implementations
configured for this grid instance will be used (i.e. failover, load balancing, collision resolution, etc.).
Note that if you need greater control on any aspects of Java code execution on the grid
you should implement <code>GridTask</code> which will provide you with full control over the execution.</p><p>Note that class <code>GridAbsClosure</code> implements <code>Runnable</code> and class <code>GridOutClosure</code>
implements <code>Callable</code> interface. Note also that class <code>GridFunc</code> and typedefs provide rich
APIs and functionality for closures and predicates based processing in GridGain. While Java interfaces
<code>Runnable</code> and <code>Callable</code> allow for lowest common denominator for APIs - it is advisable
to use richer Functional Programming support provided by GridGain available in <code>org.gridgain.grid.lang</code>
package.</p><p>Notice that <code>Runnable</code> and <code>Callable</code> implementations must support serialization as required
by the configured marshaller. For example, JDK marshaller will require that implementations would
be serializable. Other marshallers, e.g. JBoss marshaller, may not have this limitation. Please consult
with specific marshaller implementation for the details. Note that all closures and predicates in
<code>org.gridgain.grid.lang</code> package are serializable and can be freely used in the distributed
context with all marshallers currently shipped with GridGain.
</p></div><dl class="paramcmts block"><dt class="param">cacheName</dt><dd class="cmt"><p>Name of the cache to use for affinity co-location.</p></dd><dt class="param">affKeys</dt><dd class="cmt"><p>Collection of affinity keys. All dups will be ignored. If <code>null</code> or
     empty - this method is no-op.</p></dd><dt class="param">r</dt><dd class="cmt"><p>Closure to affinity co-located on the node with given affinity key and execute.
     If <code>null</code> - this method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional set of filtering predicates. All predicates must evaluate to <code>true</code> for a
     node to be included. If none provided - all nodes in this projection will be used for topology.</p></dd><dt>returns</dt><dd class="cmt"><p>Non-cancellable future of this execution.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>Exceptions thrown</dt><dd><span class="cmt">GridInterruptedException<p>Subclass of <code>GridException</code> thrown if the wait was interrupted.</p></span><span class="cmt">GridEmptyProjectionException<p>Thrown in case when this projection is empty.
     Note that in case of dynamic projection this method will take a snapshot of all the
     nodes at the time of this call, apply all filtering predicates, if any, and if the
     resulting collection of nodes is empty - the exception will be thrown.</p></span><span class="cmt">GridFutureCancelledException<p>Subclass of <code>GridException</code> thrown if computation was cancelled.
</p></span><span class="cmt">GridException<p>Thrown in case of any error.</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#aggregate" data-isabs="false">
      <a id="aggregate[B](B)((B, GridRichNode) ⇒ B,(B, B) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">aggregate</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="seqop">seqop: (B, <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ B</span>, <span name="combop">combop: (B, B) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#call$" data-isabs="false">
      <a id="call$[R](GridClosureCallMode,() ⇒ R,NodeFilter*):Seq[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">call$</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: () ⇒ R</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: Seq[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closure call on this projection with return value.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closure call on this projection with return value.
This call will block until all results are received and ready.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional closure to call. If <code>null</code> - this method is no-op and returns <code>null</code>.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Sequence of result values from all nodes where given closures were executed
     or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.call(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#call$" data-isabs="false">
      <a id="call$[R](GridClosureCallMode,Seq[() ⇒ R],NodeFilter*):Seq[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">call$</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ R]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: Seq[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closures call on this projection with return value.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closures call on this projection with return value.
This call will block until all results are received and ready.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this
     method is no-op and returns <code>null</code>.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Sequence of result values from all nodes where given closures were executed
     or <code>null</code> (see above).
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#callAsync$" data-isabs="false">
      <a id="callAsync$[R](GridClosureCallMode,() ⇒ R,NodeFilter*):GridFuture[Collection[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">callAsync$</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: () ⇒ R</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[<span name="java.util.Collection" class="extype">Collection</span>[R]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronous closure call on this projection with return value.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous closure call on this projection with return value. This call will
return immediately with the future that can be used to wait asynchronously for the results.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional closure to call. If <code>null</code> - this method is no-op and finished
     future over <code>null</code> is returned.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Future of Java collection containing result values from all nodes where given
     closures were executed or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.call(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#callAsync$" data-isabs="false">
      <a id="callAsync$[R](GridClosureCallMode,Seq[() ⇒ R],NodeFilter*):GridFuture[Collection[R]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">callAsync$</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ R]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[<span name="java.util.Collection" class="extype">Collection</span>[R]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronous closures call on this projection with return value.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous closures call on this projection with return value. This call will
return immediately with the future that can be used to wait asynchronously for the results.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this method
     is no-op and finished future over <code>null</code> is returned.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Future of Java collection containing result values from all nodes where given
     closures were executed or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.call(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#callSafe" data-isabs="false">
      <a id="callSafe[R](GridClosureCallMode,() ⇒ R,() ⇒ Seq[R],NodeFilter*):Seq[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">callSafe</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: () ⇒ R</span>, <span name="dflt">dflt: () ⇒ Seq[R]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: Seq[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closure call on this projection with return value.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closure call on this projection with return value.
This call will block until all results are received and ready. If this projection
is empty than <code>dflt</code> closure will be executed and its result returned.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional closure to call. If <code>null</code> - this method is no-op and returns <code>null</code>.</p></dd><dt class="param">dflt</dt><dd class="cmt"><p>Closure to execute if projection is empty.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Sequence of result values from all nodes where given closures were executed
     or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.call(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#callSafe" data-isabs="false">
      <a id="callSafe[R](GridClosureCallMode,Seq[() ⇒ R],() ⇒ Seq[R],NodeFilter*):Seq[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">callSafe</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ R]</span>, <span name="dflt">dflt: () ⇒ Seq[R]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: Seq[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closures call on this projection with return value.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closures call on this projection with return value.
This call will block until all results are received and ready. If this projection
is empty than <code>dflt</code> closure will be executed and its result returned.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this
     method is no-op and returns <code>null</code>.</p></dd><dt class="param">dflt</dt><dd class="cmt"><p>Closure to execute if projection is empty.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Sequence of result values from all nodes where given closures were executed
     or <code>null</code> (see above).
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#callableDotScala" data-isabs="false">
      <a id="callableDotScala[R](Callable[R]):AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">callableDotScala</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="java.util.concurrent.Callable" class="extype">Callable</span>[R]</span>)</span><span class="result">: AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side callable to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#canEqual" data-isabs="false">
      <a id="canEqual(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">canEqual</span><span class="params">(<span name="that">that: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → Equals</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#closure2DotScala" data-isabs="false">
      <a id="closure2DotScala[A1, A2, R](GridClosure2[A1, A2, R]):AnyRef { def scala: (A1, A2) =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">closure2DotScala</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosure2" class="extype">GridClosure2</span>[A1, A2, R]</span>)</span><span class="result">: AnyRef { def scala: (A1, A2) =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#closure2XDotScala" data-isabs="false">
      <a id="closure2XDotScala[A1, A2, R](GridClosure2X[A1, A2, R]):AnyRef { def scala: (A1, A2) =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">closure2XDotScala</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosure2X" class="extype">GridClosure2X</span>[A1, A2, R]</span>)</span><span class="result">: AnyRef { def scala: (A1, A2) =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#closure3DotScala" data-isabs="false">
      <a id="closure3DotScala[A1, A2, A3, R](GridClosure3[A1, A2, A3, R]):AnyRef { def scala: (A1, A2, A3) =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">closure3DotScala</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosure3" class="extype">GridClosure3</span>[A1, A2, A3, R]</span>)</span><span class="result">: AnyRef { def scala: (A1, A2, A3) =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#closure3XDotScala" data-isabs="false">
      <a id="closure3XDotScala[A1, A2, A3, R](GridClosure3X[A1, A2, A3, R]):AnyRef { def scala: (A1, A2, A3) =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">closure3XDotScala</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosure3X" class="extype">GridClosure3X</span>[A1, A2, A3, R]</span>)</span><span class="result">: AnyRef { def scala: (A1, A2, A3) =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#closureDotScala" data-isabs="false">
      <a id="closureDotScala[A, R](GridClosure[A, R]):AnyRef { def scala: A =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">closureDotScala</span><span class="tparams">[<span name="A">A</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosure" class="extype">GridClosure</span>[A, R]</span>)</span><span class="result">: AnyRef { def scala: A =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#closureXDotScala" data-isabs="false">
      <a id="closureXDotScala[A, R](GridClosureX[A, R]):AnyRef { def scala: A =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">closureXDotScala</span><span class="tparams">[<span name="A">A</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosureX" class="extype">GridClosureX</span>[A, R]</span>)</span><span class="result">: AnyRef { def scala: A =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#collect" data-isabs="false">
      <a id="collect[B, That](PartialFunction[GridRichNode, B])(CanBuildFrom[Iterable[GridRichNode], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collect</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="pf">pf: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#collectFirst" data-isabs="false">
      <a id="collectFirst[B](PartialFunction[GridRichNode, B]):Option[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectFirst</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="pf">pf: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, B]</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.Iterable#companion" data-isabs="false">
      <a id="companion:GenericCompanion[Iterable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">companion</span><span class="result">: <span name="scala.collection.generic.GenericCompanion" class="extype">GenericCompanion</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Iterable → GenIterable → Traversable → GenTraversable → GenericTraversableTemplate</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#copyToArray" data-isabs="false">
      <a id="copyToArray[B<span class='angle_bracket'>&gt;</span>:GridRichNode](Array[B],Int,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copyToArray</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="xs">xs: <span name="scala.Array" class="extype">Array</span>[B]</span>, <span name="start">start: <span name="scala.Int" class="extype">Int</span></span>, <span name="len">len: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#copyToArray" data-isabs="false">
      <a id="copyToArray[B<span class='angle_bracket'>&gt;</span>:GridRichNode](Array[B]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copyToArray</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="xs">xs: <span name="scala.Array" class="extype">Array</span>[B]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#copyToArray" data-isabs="false">
      <a id="copyToArray[B<span class='angle_bracket'>&gt;</span>:GridRichNode](Array[B],Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copyToArray</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="xs">xs: <span name="scala.Array" class="extype">Array</span>[B]</span>, <span name="start">start: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#copyToBuffer" data-isabs="false">
      <a id="copyToBuffer[B<span class='angle_bracket'>&gt;</span>:GridRichNode](Buffer[B]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copyToBuffer</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="dest">dest: <span name="scala.collection.mutable.Buffer" class="extype">Buffer</span>[B]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#count" data-isabs="false">
      <a id="count((GridRichNode) ⇒ Boolean):Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">count</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#drop" data-isabs="false">
      <a id="drop(Int):Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">drop</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#dropRight" data-isabs="false">
      <a id="dropRight(Int):Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropRight</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#dropWhile" data-isabs="false">
      <a id="dropWhile((GridRichNode) ⇒ Boolean):Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropWhile</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#exists" data-isabs="false">
      <a id="exists((GridRichNode) ⇒ Boolean):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">exists</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#filter" data-isabs="false">
      <a id="filter((GridRichNode) ⇒ Boolean):Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#filterNot" data-isabs="false">
      <a id="filterNot((GridRichNode) ⇒ Boolean):Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filterNot</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#find" data-isabs="false">
      <a id="find((GridRichNode) ⇒ Boolean):Option[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">find</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#flatMap" data-isabs="false">
      <a id="flatMap[B, That]((GridRichNode) ⇒ GenTraversableOnce[B])(CanBuildFrom[Iterable[GridRichNode], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.collection.GenTraversableOnce" class="extype">GenTraversableOnce</span>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike → FilterMonadic</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#fold" data-isabs="false">
      <a id="fold[A1<span class='angle_bracket'>&gt;</span>:GridRichNode](A1)((A1, A1) ⇒ A1):A1"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fold</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="z">z: A1</span>)</span><span class="params">(<span name="op">op: (A1, A1) ⇒ A1</span>)</span><span class="result">: A1</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#foldLeft" data-isabs="false">
      <a id="foldLeft[B](B)((B, GridRichNode) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldLeft</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (B, <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#foldRight" data-isabs="false">
      <a id="foldRight[B](B)((GridRichNode, B) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldRight</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, B) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#forall" data-isabs="false">
      <a id="forall((GridRichNode) ⇒ Boolean):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">forall</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#foreach" data-isabs="false">
      <a id="foreach[U]((GridRichNode) ⇒ U):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foreach</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ U</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableLike → TraversableOnce → GenTraversableOnce → FilterMonadic</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromAbsClosure" data-isabs="false">
      <a id="fromAbsClosure(GridAbsClosure):() ⇒ Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromAbsClosure</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridAbsClosure" class="extype">GridAbsClosure</span></span>)</span><span class="result">: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridAbsClosure</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridAbsClosure</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromAbsClosureX" data-isabs="false">
      <a id="fromAbsClosureX(GridAbsClosureX):() ⇒ Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromAbsClosureX</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridAbsClosureX" class="extype">GridAbsClosureX</span></span>)</span><span class="result">: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridAbsClosureX</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridAbsClosureX</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromAbsPredicate" data-isabs="false">
      <a id="fromAbsPredicate(GridAbsPredicate):() ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromAbsPredicate</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridAbsPredicate" class="extype">GridAbsPredicate</span></span>)</span><span class="result">: () ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridAbsPredicate</code> to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridAbsPredicate</code> to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Grid predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromAbsPredicateX" data-isabs="false">
      <a id="fromAbsPredicateX(GridAbsPredicateX):() ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromAbsPredicateX</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridAbsPredicateX" class="extype">GridAbsPredicateX</span></span>)</span><span class="result">: () ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridAbsPredicateX</code> to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridAbsPredicateX</code> to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Grid predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromCallable" data-isabs="false">
      <a id="fromCallable[R](Callable[R]):() ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromCallable</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="java.util.concurrent.Callable" class="extype">Callable</span>[R]</span>)</span><span class="result">: () ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>Callable</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>Callable</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromClosure" data-isabs="false">
      <a id="fromClosure[A, R](GridClosure[A, R]):(A) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromClosure</span><span class="tparams">[<span name="A">A</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosure" class="extype">GridClosure</span>[A, R]</span>)</span><span class="result">: (A) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridClosure</code> to Scala wrapping closure.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridClosure</code> to Scala wrapping closure.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromClosure2" data-isabs="false">
      <a id="fromClosure2[A1, A2, R](GridClosure2[A1, A2, R]):(A1, A2) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromClosure2</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosure2" class="extype">GridClosure2</span>[A1, A2, R]</span>)</span><span class="result">: (A1, A2) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridClosure2X</code> to Scala wrapping closure.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridClosure2X</code> to Scala wrapping closure.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromClosure2X" data-isabs="false">
      <a id="fromClosure2X[A1, A2, R](GridClosure2X[A1, A2, R]):(A1, A2) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromClosure2X</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosure2X" class="extype">GridClosure2X</span>[A1, A2, R]</span>)</span><span class="result">: (A1, A2) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridClosure2X</code> to Scala wrapping closure.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridClosure2X</code> to Scala wrapping closure.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromClosure3" data-isabs="false">
      <a id="fromClosure3[A1, A2, A3, R](GridClosure3[A1, A2, A3, R]):(A1, A2, A3) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromClosure3</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosure3" class="extype">GridClosure3</span>[A1, A2, A3, R]</span>)</span><span class="result">: (A1, A2, A3) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridClosure3</code> to Scala wrapping closure.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridClosure3</code> to Scala wrapping closure.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromClosure3X" data-isabs="false">
      <a id="fromClosure3X[A1, A2, A3, R](GridClosure3X[A1, A2, A3, R]):(A1, A2, A3) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromClosure3X</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosure3X" class="extype">GridClosure3X</span>[A1, A2, A3, R]</span>)</span><span class="result">: (A1, A2, A3) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridClosure3X</code> to Scala wrapping closure.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridClosure3X</code> to Scala wrapping closure.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromClosureX" data-isabs="false">
      <a id="fromClosureX[A, R](GridClosureX[A, R]):(A) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromClosureX</span><span class="tparams">[<span name="A">A</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridClosureX" class="extype">GridClosureX</span>[A, R]</span>)</span><span class="result">: (A) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridClosureX</code> to Scala wrapping closure.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridClosureX</code> to Scala wrapping closure.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromInClosure" data-isabs="false">
      <a id="fromInClosure[T](GridInClosure[T]):(T) ⇒ Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromInClosure</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosure" class="extype">GridInClosure</span>[T]</span>)</span><span class="result">: (T) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridInClosure</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridInClosure</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromInClosure2" data-isabs="false">
      <a id="fromInClosure2[T1, T2](GridInClosure2[T1, T2]):(T1, T2) ⇒ Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromInClosure2</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosure2" class="extype">GridInClosure2</span>[T1, T2]</span>)</span><span class="result">: (T1, T2) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridInClosure2</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridInClosure2</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromInClosure2X" data-isabs="false">
      <a id="fromInClosure2X[T1, T2](GridInClosure2X[T1, T2]):(T1, T2) ⇒ Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromInClosure2X</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosure2X" class="extype">GridInClosure2X</span>[T1, T2]</span>)</span><span class="result">: (T1, T2) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridInClosure2X</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridInClosure2X</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromInClosure3" data-isabs="false">
      <a id="fromInClosure3[T1, T2, T3](GridInClosure3[T1, T2, T3]):(T1, T2, T3) ⇒ Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromInClosure3</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosure3" class="extype">GridInClosure3</span>[T1, T2, T3]</span>)</span><span class="result">: (T1, T2, T3) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridInClosure3</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridInClosure3</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromInClosure3X" data-isabs="false">
      <a id="fromInClosure3X[T1, T2, T3](GridInClosure3X[T1, T2, T3]):(T1, T2, T3) ⇒ Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromInClosure3X</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosure3X" class="extype">GridInClosure3X</span>[T1, T2, T3]</span>)</span><span class="result">: (T1, T2, T3) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridInClosure3X</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridInClosure3X</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromInClosureX" data-isabs="false">
      <a id="fromInClosureX[T](GridInClosureX[T]):(T) ⇒ Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromInClosureX</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosureX" class="extype">GridInClosureX</span>[T]</span>)</span><span class="result">: (T) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridInClosureX</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridInClosureX</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromOutClosure" data-isabs="false">
      <a id="fromOutClosure[R](GridOutClosure[R]):() ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromOutClosure</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridOutClosure" class="extype">GridOutClosure</span>[R]</span>)</span><span class="result">: () ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridOutClosure</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridOutClosure</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromOutClosureX" data-isabs="false">
      <a id="fromOutClosureX[R](GridOutClosureX[R]):() ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromOutClosureX</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridOutClosureX" class="extype">GridOutClosureX</span>[R]</span>)</span><span class="result">: () ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridOutClosureX</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridOutClosureX</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromPredicate" data-isabs="false">
      <a id="fromPredicate[T](GridPredicate[T]):(T) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromPredicate</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicate" class="extype">GridPredicate</span>[T]</span>)</span><span class="result">: (T) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridPredicate</code> to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridPredicate</code> to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Grid predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromPredicate2" data-isabs="false">
      <a id="fromPredicate2[T1, T2](GridPredicate2[T1, T2]):(T1, T2) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromPredicate2</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicate2" class="extype">GridPredicate2</span>[T1, T2]</span>)</span><span class="result">: (T1, T2) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridPredicate2X</code> to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridPredicate2X</code> to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Grid predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromPredicate2X" data-isabs="false">
      <a id="fromPredicate2X[T1, T2](GridPredicate2X[T1, T2]):(T1, T2) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromPredicate2X</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicate2X" class="extype">GridPredicate2X</span>[T1, T2]</span>)</span><span class="result">: (T1, T2) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridPredicate2X</code> to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridPredicate2X</code> to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Grid predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromPredicate3" data-isabs="false">
      <a id="fromPredicate3[T1, T2, T3](GridPredicate3[T1, T2, T3]):(T1, T2, T3) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromPredicate3</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicate3" class="extype">GridPredicate3</span>[T1, T2, T3]</span>)</span><span class="result">: (T1, T2, T3) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridPredicate3X</code> to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridPredicate3X</code> to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Grid predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromPredicate3X" data-isabs="false">
      <a id="fromPredicate3X[T1, T2, T3](GridPredicate3X[T1, T2, T3]):(T1, T2, T3) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromPredicate3X</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicate3X" class="extype">GridPredicate3X</span>[T1, T2, T3]</span>)</span><span class="result">: (T1, T2, T3) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridPredicate3X</code> to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridPredicate3X</code> to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Grid predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromPredicateX" data-isabs="false">
      <a id="fromPredicateX[T](GridPredicateX[T]):(T) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromPredicateX</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicateX" class="extype">GridPredicateX</span>[T]</span>)</span><span class="result">: (T) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridPredicate</code> to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridPredicate</code> to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Grid predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromReducer" data-isabs="false">
      <a id="fromReducer[E, R](GridReducer[E, R]):(Seq[E]) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromReducer</span><span class="tparams">[<span name="E">E</span>, <span name="R">R</span>]</span><span class="params">(<span name="r">r: <span name="org.gridgain.grid.lang.GridReducer" class="extype">GridReducer</span>[E, R]</span>)</span><span class="result">: (<span name="scala.collection.Seq" class="extype">Seq</span>[E]) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Java <code>GridReducer</code> to Scala function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Java <code>GridReducer</code> to Scala function.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Java <code>GridReducer</code> to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromReducer2" data-isabs="false">
      <a id="fromReducer2[E1, E2, R](GridReducer2[E1, E2, R]):(Seq[E1], Seq[E2]) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromReducer2</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="R">R</span>]</span><span class="params">(<span name="r">r: <span name="org.gridgain.grid.lang.GridReducer2" class="extype">GridReducer2</span>[E1, E2, R]</span>)</span><span class="result">: (<span name="scala.collection.Seq" class="extype">Seq</span>[E1], <span name="scala.collection.Seq" class="extype">Seq</span>[E2]) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Java <code>GridReducer2</code> to Scala function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Java <code>GridReducer2</code> to Scala function.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Java <code>GridReducer2</code> to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromReducer3" data-isabs="false">
      <a id="fromReducer3[E1, E2, E3, R](GridReducer3[E1, E2, E3, R]):(Seq[E1], Seq[E2], Seq[E3]) ⇒ R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromReducer3</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="E3">E3</span>, <span name="R">R</span>]</span><span class="params">(<span name="r">r: <span name="org.gridgain.grid.lang.GridReducer3" class="extype">GridReducer3</span>[E1, E2, E3, R]</span>)</span><span class="result">: (<span name="scala.collection.Seq" class="extype">Seq</span>[E1], <span name="scala.collection.Seq" class="extype">Seq</span>[E2], <span name="scala.collection.Seq" class="extype">Seq</span>[E3]) ⇒ R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Java <code>GridReducer3</code> to Scala function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Java <code>GridReducer3</code> to Scala function.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Java <code>GridReducer3</code> to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromRunnable" data-isabs="false">
      <a id="fromRunnable(Runnable):() ⇒ Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromRunnable</span><span class="params">(<span name="f">f: <span name="java.lang.Runnable" class="extype">Runnable</span></span>)</span><span class="result">: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>Runnable</code> to Scala wrapping function.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>Runnable</code> to Scala wrapping function.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Grid closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromSymbol" data-isabs="false">
      <a id="fromSymbol(Symbol):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromSymbol</span><span class="params">(<span name="s">s: <span name="scala.Symbol" class="extype">Symbol</span></span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Converts from <code>Symbol</code> to <code>String</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts from <code>Symbol</code> to <code>String</code>.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>Symbol to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromTuple2" data-isabs="false">
      <a id="fromTuple2[A, B](GridTuple2[A, B]):(A, B)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromTuple2</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="t">t: <span name="org.gridgain.grid.lang.GridTuple2" class="extype">GridTuple2</span>[A, B]</span>)</span><span class="result">: (A, B)</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridTuple2</code> to Scala tuple.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridTuple2</code> to Scala tuple.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p><code>GridTuple2</code> to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromTuple3" data-isabs="false">
      <a id="fromTuple3[A, B, C](GridTuple3[A, B, C]):(A, B, C)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromTuple3</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="t">t: <span name="org.gridgain.grid.lang.GridTuple3" class="extype">GridTuple3</span>[A, B, C]</span>)</span><span class="result">: (A, B, C)</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridTuple3</code> to Scala tuple.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridTuple3</code> to Scala tuple.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p><code>GridTuple3</code> to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromTuple4" data-isabs="false">
      <a id="fromTuple4[A, B, C, D](GridTuple4[A, B, C, D]):(A, B, C, D)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromTuple4</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="D">D</span>]</span><span class="params">(<span name="t">t: <span name="org.gridgain.grid.lang.GridTuple4" class="extype">GridTuple4</span>[A, B, C, D]</span>)</span><span class="result">: (A, B, C, D)</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridTuple4</code> to Scala tuple.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridTuple4</code> to Scala tuple.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p><code>GridTuple4</code> to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#fromTuple5" data-isabs="false">
      <a id="fromTuple5[A, B, C, D, E](GridTuple5[A, B, C, D, E]):(A, B, C, D, E)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fromTuple5</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="D">D</span>, <span name="E">E</span>]</span><span class="params">(<span name="t">t: <span name="org.gridgain.grid.lang.GridTuple5" class="extype">GridTuple5</span>[A, B, C, D, E]</span>)</span><span class="result">: (A, B, C, D, E)</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridTuple5</code> to Scala tuple.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridTuple5</code> to Scala tuple.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p><code>GridTuple5</code> to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.generic.GenericTraversableTemplate#genericBuilder" data-isabs="false">
      <a id="genericBuilder[B]:Builder[B, Iterable[B]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">genericBuilder</span><span class="tparams">[<span name="B">B</span>]</span><span class="result">: <span name="scala.collection.mutable.Builder" class="extype">Builder</span>[B, <span name="scala.collection.Iterable" class="extype">Iterable</span>[B]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenericTraversableTemplate</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#gridify$" data-isabs="false">
      <a id="gridify$[E1, E2, E3, R](GridClosureCallMode,(E1, E2, E3) ⇒ R,NodeFilter*):(E1, E2, E3) ⇒ GridFuture[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gridify$</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="E3">E3</span>, <span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="c">c: (E1, E2, E3) ⇒ R</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: (E1, E2, E3) ⇒ <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Curries given closure into distribution version of it.</p><div class="fullcomment"><div class="comment cmt"><p>Curries given closure into distribution version of it. When resulting closure is
called it will return future without blocking and execute given closure asynchronously
on this projection using given closure call mode.</p><p>This method effectively allows to convert &quot;local&quot; closure into a distributed one
that will take the same parameters (if any), execute &quot;somewhere&quot; on this projection,
and produce the same result but via future.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode with to curry given closure.</p></dd><dt class="param">c</dt><dd class="cmt"><p>Closure to convert.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional set of filtering predicates. If none provided - all nodes from this
     projection will be candidates for load balancing.</p></dd><dt>returns</dt><dd class="cmt"><p>Distributed-on-this-projection version of the given closure.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.gridify(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#gridify$" data-isabs="false">
      <a id="gridify$[E1, E2, R](GridClosureCallMode,(E1, E2) ⇒ R,NodeFilter*):(E1, E2) ⇒ GridFuture[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gridify$</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="c">c: (E1, E2) ⇒ R</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: (E1, E2) ⇒ <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Curries given closure into distribution version of it.</p><div class="fullcomment"><div class="comment cmt"><p>Curries given closure into distribution version of it. When resulting closure is
called it will return future without blocking and execute given closure asynchronously
on this projection using given closure call mode.</p><p>This method effectively allows to convert &quot;local&quot; closure into a distributed one
that will take the same parameters (if any), execute &quot;somewhere&quot; on this projection,
and produce the same result but via future.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode with to curry given closure.</p></dd><dt class="param">c</dt><dd class="cmt"><p>Closure to convert.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional set of filtering predicates. If none provided - all nodes from this
     projection will be candidates for load balancing.</p></dd><dt>returns</dt><dd class="cmt"><p>Distributed-on-this-projection version of the given closure.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.gridify(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#gridify$" data-isabs="false">
      <a id="gridify$[E1, R](GridClosureCallMode,(E1) ⇒ R,NodeFilter*):(E1) ⇒ GridFuture[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gridify$</span><span class="tparams">[<span name="E1">E1</span>, <span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="c">c: (E1) ⇒ R</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: (E1) ⇒ <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Curries given closure into distribution version of it.</p><div class="fullcomment"><div class="comment cmt"><p>Curries given closure into distribution version of it. When resulting closure is
called it will return future without blocking and execute given closure asynchronously
on this projection using given closure call mode.</p><p>This method effectively allows to convert &quot;local&quot; closure into a distributed one
that will take the same parameters (if any), execute &quot;somewhere&quot; on this projection,
and produce the same result but via future.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode with to curry given closure.</p></dd><dt class="param">c</dt><dd class="cmt"><p>Closure to convert.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional set of filtering predicates. If none provided - all nodes from this
     projection will be candidates for load balancing.</p></dd><dt>returns</dt><dd class="cmt"><p>Distributed-on-this-projection version of the given closure.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.gridify(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#gridify$" data-isabs="false">
      <a id="gridify$[R](GridClosureCallMode,() ⇒ R,NodeFilter*):() ⇒ GridFuture[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gridify$</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="c">c: () ⇒ R</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: () ⇒ <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Curries given closure into distribution version of it.</p><div class="fullcomment"><div class="comment cmt"><p>Curries given closure into distribution version of it. When resulting closure is
called it will return future without blocking and execute given closure asynchronously
on this projection using given closure call mode.</p><p>This method effectively allows to convert &quot;local&quot; closure into a distributed one
that will take the same parameters (if any), execute &quot;somewhere&quot; on this projection,
and produce the same result but via future.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode with to curry given closure.</p></dd><dt class="param">c</dt><dd class="cmt"><p>Closure to convert.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional set of filtering predicates. If none provided - all nodes from this
     projection will be candidates for load balancing.</p></dd><dt>returns</dt><dd class="cmt"><p>Distributed-on-this-projection version of the given closure.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.gridify(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#groupBy" data-isabs="false">
      <a id="groupBy[K]((GridRichNode) ⇒ K):Map[K, Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">groupBy</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ K</span>)</span><span class="result">: <span name="scala.collection.immutable.Map" class="extype">Map</span>[K, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#grouped" data-isabs="false">
      <a id="grouped(Int):Iterator[Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">grouped</span><span class="params">(<span name="size">size: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#hasDefiniteSize" data-isabs="false">
      <a id="hasDefiniteSize:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hasDefiniteSize</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#head" data-isabs="false">
      <a id="head:GridRichNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">head</span><span class="result">: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike → TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#headOption" data-isabs="false">
      <a id="headOption:Option[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">headOption</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="prt" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#impl" data-isabs="false">
      <a id="impl:Grid"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">var</span>
      </span>
      <span class="symbol">
        <span class="name">impl</span><span class="result">: <span name="org.gridgain.grid.Grid" class="extype">Grid</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#inClosure2DotScala" data-isabs="false">
      <a id="inClosure2DotScala[T1, T2](GridInClosure2[T1, T2]):AnyRef { def scala: (T1, T2) =<span class='angle_bracket'>&gt;</span> Unit }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inClosure2DotScala</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosure2" class="extype">GridInClosure2</span>[T1, T2]</span>)</span><span class="result">: AnyRef { def scala: (T1, T2) =<span class='angle_bracket'>&gt;</span> Unit }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#inClosure2XDotScala" data-isabs="false">
      <a id="inClosure2XDotScala[T1, T2](GridInClosure2X[T1, T2]):AnyRef { def scala: (T1, T2) =<span class='angle_bracket'>&gt;</span> Unit }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inClosure2XDotScala</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosure2X" class="extype">GridInClosure2X</span>[T1, T2]</span>)</span><span class="result">: AnyRef { def scala: (T1, T2) =<span class='angle_bracket'>&gt;</span> Unit }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#inClosure3DotScala" data-isabs="false">
      <a id="inClosure3DotScala[T1, T2, T3](GridInClosure3[T1, T2, T3]):AnyRef { def scala: (T1, T2, T3) =<span class='angle_bracket'>&gt;</span> Unit }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inClosure3DotScala</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosure3" class="extype">GridInClosure3</span>[T1, T2, T3]</span>)</span><span class="result">: AnyRef { def scala: (T1, T2, T3) =<span class='angle_bracket'>&gt;</span> Unit }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#inClosure3XDotScala" data-isabs="false">
      <a id="inClosure3XDotScala[T1, T2, T3](GridInClosure3X[T1, T2, T3]):AnyRef { def scala: (T1, T2, T3) =<span class='angle_bracket'>&gt;</span> Unit }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inClosure3XDotScala</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosure3X" class="extype">GridInClosure3X</span>[T1, T2, T3]</span>)</span><span class="result">: AnyRef { def scala: (T1, T2, T3) =<span class='angle_bracket'>&gt;</span> Unit }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#inClosureDotScala" data-isabs="false">
      <a id="inClosureDotScala[T](GridInClosure[T]):AnyRef { def scala: T =<span class='angle_bracket'>&gt;</span> Unit }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inClosureDotScala</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosure" class="extype">GridInClosure</span>[T]</span>)</span><span class="result">: AnyRef { def scala: T =<span class='angle_bracket'>&gt;</span> Unit }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#inClosureXDotScala" data-isabs="false">
      <a id="inClosureXDotScala[T](GridInClosureX[T]):AnyRef { def scala: T =<span class='angle_bracket'>&gt;</span> Unit }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inClosureXDotScala</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridInClosureX" class="extype">GridInClosureX</span>[T]</span>)</span><span class="result">: AnyRef { def scala: T =<span class='angle_bracket'>&gt;</span> Unit }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#init" data-isabs="false">
      <a id="init:Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">init</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#inits" data-isabs="false">
      <a id="inits:Iterator[Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inits</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#isEmpty" data-isabs="false">
      <a id="isEmpty:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isEmpty</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike → TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.GenTraversableLike#isTraversableAgain" data-isabs="false">
      <a id="isTraversableAgain:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isTraversableAgain</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenTraversableLike → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#iterator" data-isabs="false">
      <a id="iterator:Iterator[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">iterator</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets iterator for this projection's nodes.</p><div class="fullcomment"><div class="comment cmt"><p>Gets iterator for this projection's nodes.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a> → IterableLike → GenIterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#last" data-isabs="false">
      <a id="last:GridRichNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">last</span><span class="result">: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#lastOption" data-isabs="false">
      <a id="lastOption:Option[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lastOption</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#map" data-isabs="false">
      <a id="map[B, That]((GridRichNode) ⇒ B)(CanBuildFrom[Iterable[GridRichNode], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike → FilterMonadic</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#mapreduce$" data-isabs="false">
      <a id="mapreduce$[R1, R2]((Seq[GridRichNode]) ⇒ (Callable[R1]) ⇒ GridRichNode,Seq[() ⇒ R1],(Seq[R1]) ⇒ R2,NodeFilter*):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapreduce$</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="m">m: (Seq[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]) ⇒ (<span name="java.util.concurrent.Callable" class="extype">Callable</span>[R1]) ⇒ <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>, <span name="s">s: Seq[() ⇒ R1]</span>, <span name="r">r: (Seq[R1]) ⇒ R2</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closures execution on this projection with mapping and reduction.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closures execution on this projection with mapping and reduction.
This call will block until all results are reduced.
</p></div><dl class="paramcmts block"><dt class="param">m</dt><dd class="cmt"><p>Mapping function.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">r</dt><dd class="cmt"><p>Optional reduction function. If <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced result or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.mapreduce(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#mapreduceAsync$" data-isabs="false">
      <a id="mapreduceAsync$[R1, R2]((Seq[GridRichNode]) ⇒ (Callable[R1]) ⇒ GridRichNode,Seq[() ⇒ R1],(Seq[R1]) ⇒ R2,NodeFilter*):GridFuture[R2]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapreduceAsync$</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="m">m: (Seq[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]) ⇒ (<span name="java.util.concurrent.Callable" class="extype">Callable</span>[R1]) ⇒ <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>, <span name="s">s: Seq[() ⇒ R1]</span>, <span name="r">r: (Seq[R1]) ⇒ R2</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[R2]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronous closures execution on this projection with mapping and reduction.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous closures execution on this projection with mapping and reduction.
This call will return immediately with the future that can be used to wait asynchronously for
the results.
</p></div><dl class="paramcmts block"><dt class="param">m</dt><dd class="cmt"><p>Mapping function.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">r</dt><dd class="cmt"><p>Optional reduction function. If <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Future over the reduced result or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.mapreduce(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#mapreduceSafe" data-isabs="false">
      <a id="mapreduceSafe[R1, R2]((Seq[GridRichNode]) ⇒ (Callable[R1]) ⇒ GridRichNode,Seq[() ⇒ R1],(Seq[R1]) ⇒ R2,() ⇒ R2,NodeFilter*):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapreduceSafe</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="m">m: (Seq[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]) ⇒ (<span name="java.util.concurrent.Callable" class="extype">Callable</span>[R1]) ⇒ <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>, <span name="s">s: Seq[() ⇒ R1]</span>, <span name="r">r: (Seq[R1]) ⇒ R2</span>, <span name="dflt">dflt: () ⇒ R2</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closures execution on this projection with mapping and reduction.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closures execution on this projection with mapping and reduction.
This call will block until all results are reduced. If this projection
is empty than <code>dflt</code> closure will be executed and its result returned.
</p></div><dl class="paramcmts block"><dt class="param">m</dt><dd class="cmt"><p>Mapping function.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">r</dt><dd class="cmt"><p>Optional reduction function. If <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">dflt</dt><dd class="cmt"><p>Closure to execute if projection is empty.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced result or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.mapreduce(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#max" data-isabs="false">
      <a id="max[B<span class='angle_bracket'>&gt;</span>:GridRichNode](Ordering[B]):GridRichNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">max</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="cmp">cmp: Ordering[B]</span>)</span><span class="result">: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#maxBy" data-isabs="false">
      <a id="maxBy[B]((GridRichNode) ⇒ B)(Ordering[B]):GridRichNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">maxBy</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="cmp">cmp: Ordering[B]</span>)</span><span class="result">: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#min" data-isabs="false">
      <a id="min[B<span class='angle_bracket'>&gt;</span>:GridRichNode](Ordering[B]):GridRichNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">min</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="cmp">cmp: Ordering[B]</span>)</span><span class="result">: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#minBy" data-isabs="false">
      <a id="minBy[B]((GridRichNode) ⇒ B)(Ordering[B]):GridRichNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">minBy</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="cmp">cmp: Ordering[B]</span>)</span><span class="result">: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#mkString" data-isabs="false">
      <a id="mkString:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mkString</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#mkString" data-isabs="false">
      <a id="mkString(String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mkString</span><span class="params">(<span name="sep">sep: String</span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#mkString" data-isabs="false">
      <a id="mkString(String,String,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mkString</span><span class="params">(<span name="start">start: String</span>, <span name="sep">sep: String</span>, <span name="end">end: String</span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="prt" name="scala.collection.generic.GenericTraversableTemplate#newBuilder" data-isabs="false">
      <a id="newBuilder:Builder[GridRichNode, Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">newBuilder</span><span class="result">: <span name="scala.collection.mutable.Builder" class="extype">Builder</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[this] </dd><dt>Definition Classes</dt><dd>GenericTraversableTemplate → HasNewBuilder</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#nodes$" data-isabs="false">
      <a id="nodes$(NodeFilter*):Seq[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nodes$</span><span class="params">(<span name="p">p: NodeFilter*</span>)</span><span class="result">: Seq[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets sequence of all nodes in this projection for given predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Gets sequence of all nodes in this projection for given predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicates. It none provided or <code>null</code> -
     all nodes will be returned.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.nodes(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#nonEmpty" data-isabs="false">
      <a id="nonEmpty:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nonEmpty</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#outClosureDotScala" data-isabs="false">
      <a id="outClosureDotScala[R](GridOutClosure[R]):AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">outClosureDotScala</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridOutClosure" class="extype">GridOutClosure</span>[R]</span>)</span><span class="result">: AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#outClosureXDotScala" data-isabs="false">
      <a id="outClosureXDotScala[R](GridOutClosureX[R]):AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">outClosureXDotScala</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: <span name="org.gridgain.grid.lang.GridOutClosureX" class="extype">GridOutClosureX</span>[R]</span>)</span><span class="result">: AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side closure to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.Parallelizable#par" data-isabs="false">
      <a id="par:ParIterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">par</span><span class="result">: <span name="scala.collection.parallel.ParIterable" class="extype">ParIterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parallelizable</dd></dl></div>
    </li><li visbl="prt" name="scala.collection.TraversableLike#parCombiner" data-isabs="false">
      <a id="parCombiner:Combiner[GridRichNode, ParIterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parCombiner</span><span class="result">: <span name="scala.collection.parallel.Combiner" class="extype">Combiner</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.parallel.ParIterable" class="extype">ParIterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[this] </dd><dt>Definition Classes</dt><dd>TraversableLike → Parallelizable</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#partition" data-isabs="false">
      <a id="partition((GridRichNode) ⇒ Boolean):(Iterable[GridRichNode], Iterable[GridRichNode])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">partition</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>])</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#predicate2DotScala" data-isabs="false">
      <a id="predicate2DotScala[T1, T2](GridPredicate2[T1, T2]):AnyRef { def scala: (T1, T2) =<span class='angle_bracket'>&gt;</span> Boolean }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">predicate2DotScala</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicate2" class="extype">GridPredicate2</span>[T1, T2]</span>)</span><span class="result">: AnyRef { def scala: (T1, T2) =<span class='angle_bracket'>&gt;</span> Boolean }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Java-side predicate to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#predicate2XDotScala" data-isabs="false">
      <a id="predicate2XDotScala[T1, T2](GridPredicate2X[T1, T2]):AnyRef { def scala: (T1, T2) =<span class='angle_bracket'>&gt;</span> Boolean }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">predicate2XDotScala</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicate2X" class="extype">GridPredicate2X</span>[T1, T2]</span>)</span><span class="result">: AnyRef { def scala: (T1, T2) =<span class='angle_bracket'>&gt;</span> Boolean }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Java-side predicate to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#predicate3DotScala" data-isabs="false">
      <a id="predicate3DotScala[T1, T2, T3](GridPredicate3[T1, T2, T3]):AnyRef { def scala: (T1, T2, T3) =<span class='angle_bracket'>&gt;</span> Boolean }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">predicate3DotScala</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicate3" class="extype">GridPredicate3</span>[T1, T2, T3]</span>)</span><span class="result">: AnyRef { def scala: (T1, T2, T3) =<span class='angle_bracket'>&gt;</span> Boolean }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Java-side predicate to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#predicate3XDotScala" data-isabs="false">
      <a id="predicate3XDotScala[T1, T2, T3](GridPredicate3X[T1, T2, T3]):AnyRef { def scala: (T1, T2, T3) =<span class='angle_bracket'>&gt;</span> Boolean }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">predicate3XDotScala</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicate3X" class="extype">GridPredicate3X</span>[T1, T2, T3]</span>)</span><span class="result">: AnyRef { def scala: (T1, T2, T3) =<span class='angle_bracket'>&gt;</span> Boolean }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Java-side predicate to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#predicateDotScala" data-isabs="false">
      <a id="predicateDotScala[T](GridPredicate[T]):AnyRef { def scala: T =<span class='angle_bracket'>&gt;</span> Boolean }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">predicateDotScala</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicate" class="extype">GridPredicate</span>[T]</span>)</span><span class="result">: AnyRef { def scala: T =<span class='angle_bracket'>&gt;</span> Boolean }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Java-side predicate to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#predicateXDotScala" data-isabs="false">
      <a id="predicateXDotScala[T](GridPredicateX[T]):AnyRef { def scala: T =<span class='angle_bracket'>&gt;</span> Boolean }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">predicateXDotScala</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="org.gridgain.grid.lang.GridPredicateX" class="extype">GridPredicateX</span>[T]</span>)</span><span class="result">: AnyRef { def scala: T =<span class='angle_bracket'>&gt;</span> Boolean }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Java-side predicate to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#product" data-isabs="false">
      <a id="product[B<span class='angle_bracket'>&gt;</span>:GridRichNode](Numeric[B]):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">product</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: Numeric[B]</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#reduce" data-isabs="false">
      <a id="reduce[A1<span class='angle_bracket'>&gt;</span>:GridRichNode]((A1, A1) ⇒ A1):A1"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduce</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="op">op: (A1, A1) ⇒ A1</span>)</span><span class="result">: A1</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#reduce$" data-isabs="false">
      <a id="reduce$[R1, R2](GridClosureCallMode,Seq[() ⇒ R1],(Seq[R1]) ⇒ R2,NodeFilter*):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduce$</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ R1]</span>, <span name="r">r: (Seq[R1]) ⇒ R2</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closures execution on this projection with reduction.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closures execution on this projection with reduction.
This call will block until all results are reduced.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">r</dt><dd class="cmt"><p>Optional reduction function. If <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced result or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.reduce(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#reduceAsync$" data-isabs="false">
      <a id="reduceAsync$[R1, R2](GridClosureCallMode,Seq[() ⇒ R1],(Seq[R1]) ⇒ R2,NodeFilter*):GridFuture[R2]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceAsync$</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ R1]</span>, <span name="r">r: (Seq[R1]) ⇒ R2</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="org.gridgain.grid.GridFuture" class="extype">GridFuture</span>[R2]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronous closures execution on this projection with reduction.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous closures execution on this projection with reduction. This call will
return immediately with the future that can be used to wait asynchronously for the results.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this method
     is no-op and will return finished future over <code>null</code>.</p></dd><dt class="param">r</dt><dd class="cmt"><p>Optional reduction function. If <code>null</code> - this method
     is no-op and will return finished future over <code>null</code>.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Future over the reduced result or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.reduce(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#reduceLeft" data-isabs="false">
      <a id="reduceLeft[B<span class='angle_bracket'>&gt;</span>:GridRichNode]((B, GridRichNode) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceLeft</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="op">op: (B, <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#reduceLeftOption" data-isabs="false">
      <a id="reduceLeftOption[B<span class='angle_bracket'>&gt;</span>:GridRichNode]((B, GridRichNode) ⇒ B):Option[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceLeftOption</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="op">op: (B, <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ B</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#reduceOption" data-isabs="false">
      <a id="reduceOption[A1<span class='angle_bracket'>&gt;</span>:GridRichNode]((A1, A1) ⇒ A1):Option[A1]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceOption</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="op">op: (A1, A1) ⇒ A1</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[A1]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#reduceRight" data-isabs="false">
      <a id="reduceRight[B<span class='angle_bracket'>&gt;</span>:GridRichNode]((GridRichNode, B) ⇒ B):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceRight</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="op">op: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, B) ⇒ B</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#reduceRightOption" data-isabs="false">
      <a id="reduceRightOption[B<span class='angle_bracket'>&gt;</span>:GridRichNode]((GridRichNode, B) ⇒ B):Option[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceRightOption</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="op">op: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, B) ⇒ B</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#reduceSafe" data-isabs="false">
      <a id="reduceSafe[R1, R2](GridClosureCallMode,Seq[() ⇒ R1],(Seq[R1]) ⇒ R2,() ⇒ R2,NodeFilter*):R2"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceSafe</span><span class="tparams">[<span name="R1">R1</span>, <span name="R2">R2</span>]</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ R1]</span>, <span name="r">r: (Seq[R1]) ⇒ R2</span>, <span name="dflt">dflt: () ⇒ R2</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: R2</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closures execution on this projection with reduction.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closures execution on this projection with reduction.
This call will block until all results are reduced. If this projection
is empty than <code>dflt</code> closure will be executed and its result returned.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">r</dt><dd class="cmt"><p>Optional reduction function. If <code>null</code> - this method
     is no-op and will return <code>null</code>.</p></dd><dt class="param">dflt</dt><dd class="cmt"><p>Closure to execute if projection is empty.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd><dt>returns</dt><dd class="cmt"><p>Reduced result or <code>null</code> (see above).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.reduce(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#reducer2DotScala" data-isabs="false">
      <a id="reducer2DotScala[E1, E2, R](GridReducer2[E1, E2, R]):AnyRef { def scala: (Seq[E1], Seq[E2]) =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reducer2DotScala</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="R">R</span>]</span><span class="params">(<span name="r">r: <span name="org.gridgain.grid.lang.GridReducer2" class="extype">GridReducer2</span>[E1, E2, R]</span>)</span><span class="result">: AnyRef { def scala: (Seq[E1], Seq[E2]) =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Java-side reducer to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#reducer3DotScala" data-isabs="false">
      <a id="reducer3DotScala[E1, E2, E3, R](GridReducer3[E1, E2, E3, R]):AnyRef { def scala: (Seq[E1], Seq[E2], Seq[E3]) =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reducer3DotScala</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="E3">E3</span>, <span name="R">R</span>]</span><span class="params">(<span name="r">r: <span name="org.gridgain.grid.lang.GridReducer3" class="extype">GridReducer3</span>[E1, E2, E3, R]</span>)</span><span class="result">: AnyRef { def scala: (Seq[E1], Seq[E2], Seq[E3]) =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Java-side reducer to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#reducerDotScala" data-isabs="false">
      <a id="reducerDotScala[E, R](GridReducer[E, R]):AnyRef { def scala: Seq[E] =<span class='angle_bracket'>&gt;</span> R }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reducerDotScala</span><span class="tparams">[<span name="E">E</span>, <span name="R">R</span>]</span><span class="params">(<span name="r">r: <span name="org.gridgain.grid.lang.GridReducer" class="extype">GridReducer</span>[E, R]</span>)</span><span class="result">: AnyRef { def scala: Seq[E] =<span class='angle_bracket'>&gt;</span> R }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Java-side reducer to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#remoteNodes$" data-isabs="false">
      <a id="remoteNodes$(NodeFilter*):Seq[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">remoteNodes$</span><span class="params">(<span name="p">p: NodeFilter*</span>)</span><span class="result">: Seq[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets sequence of all remote nodes in this projection for given predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Gets sequence of all remote nodes in this projection for given predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicates. It none provided or <code>null</code> -
     all remote nodes will be returned.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.remoteNodes(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#repr" data-isabs="false">
      <a id="repr:Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repr</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="prt" name="scala.collection.TraversableOnce#reversed" data-isabs="false">
      <a id="reversed:List[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reversed</span><span class="result">: List[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[this] </dd><dt>Definition Classes</dt><dd>TraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#run$" data-isabs="false">
      <a id="run$(GridClosureCallMode,() ⇒ Unit,NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">run$</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closure call on this projection without return value.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closure call on this projection without return value.
This call will block until all executions are complete.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional closure to call. If empty or <code>null</code> - this method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.run(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#run$" data-isabs="false">
      <a id="run$(GridClosureCallMode,Seq[() ⇒ Unit],NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">run$</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ <span name="scala.Unit" class="extype">Unit</span>]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closures call on this projection without return value.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closures call on this projection without return value.
This call will block until all executions are complete.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this
     method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.run(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#runAsync$" data-isabs="false">
      <a id="runAsync$(GridClosureCallMode,() ⇒ Unit,NodeFilter*):org.gridgain.grid.GridFuture[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">runAsync$</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: org.gridgain.grid.GridFuture[_]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronous closure call on this projection without return value.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous closure call on this projection without return value. This call will
return immediately with the future that can be used to wait asynchronously for the results.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional absolute closure to call. If <code>null</code> - this method
     is no-op and finished future over <code>null</code> will be returned.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.run(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#runAsync$" data-isabs="false">
      <a id="runAsync$(GridClosureCallMode,Seq[() ⇒ Unit],NodeFilter*):org.gridgain.grid.GridFuture[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">runAsync$</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ <span name="scala.Unit" class="extype">Unit</span>]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: org.gridgain.grid.GridFuture[_]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronous closures call on this projection without return value.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous closures call on this projection without return value. This call will
return immediately with the future that can be used to wait asynchronously for the results.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of absolute closures to call. If empty or <code>null</code> - this method
     is no-op and finished future over <code>null</code> will be returned.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.call(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#runSafe" data-isabs="false">
      <a id="runSafe(GridClosureCallMode,() ⇒ Unit,() ⇒ Unit,NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">runSafe</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="dflt">dflt: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closure call on this projection without return value.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closure call on this projection without return value.
This call will block until all executions are complete. If this projection
is empty than <code>dflt</code> closure will be executed.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional closure to call. If empty or <code>null</code> - this method is no-op.</p></dd><dt class="param">dflt</dt><dd class="cmt"><p>Closure to execute if projection is empty.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.run(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#runSafe" data-isabs="false">
      <a id="runSafe(GridClosureCallMode,Seq[() ⇒ Unit],() ⇒ Unit,NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">runSafe</span><span class="params">(<span name="mode">mode: <span name="org.gridgain.grid.GridClosureCallMode" class="extype">GridClosureCallMode</span></span>, <span name="s">s: Seq[() ⇒ <span name="scala.Unit" class="extype">Unit</span>]</span>, <span name="dflt">dflt: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronous closures call on this projection without return value.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous closures call on this projection without return value.
This call will block until all executions are complete. If this projection
is empty than <code>dflt</code> closure will be executed.
</p></div><dl class="paramcmts block"><dt class="param">mode</dt><dd class="cmt"><p>Closure call mode.</p></dd><dt class="param">s</dt><dd class="cmt"><p>Optional sequence of closures to call. If empty or <code>null</code> - this
     method is no-op.</p></dd><dt class="param">dflt</dt><dd class="cmt"><p>Closure to execute if projection is empty.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicate. If none provided or <code>null</code> - all
     nodes in projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.run(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#runnableDotScala" data-isabs="false">
      <a id="runnableDotScala(Runnable):AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> Unit }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">runnableDotScala</span><span class="params">(<span name="f">f: <span name="java.lang.Runnable" class="extype">Runnable</span></span>)</span><span class="result">: AnyRef { def scala: () =<span class='angle_bracket'>&gt;</span> Unit }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Java-side callable to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#sameElements" data-isabs="false">
      <a id="sameElements[B<span class='angle_bracket'>&gt;</span>:GridRichNode](GenIterable[B]):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sameElements</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.GenIterable" class="extype">GenIterable</span>[B]</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#scan" data-isabs="false">
      <a id="scan[B<span class='angle_bracket'>&gt;</span>:GridRichNode, That](B)((B, B) ⇒ B)(CanBuildFrom[Iterable[GridRichNode], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>, <span name="That">That</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (B, B) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="cbf">cbf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#scanLeft" data-isabs="false">
      <a id="scanLeft[B, That](B)((B, GridRichNode) ⇒ B)(CanBuildFrom[Iterable[GridRichNode], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanLeft</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (B, <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#scanRight" data-isabs="false">
      <a id="scanRight[B, That](B)((GridRichNode, B) ⇒ B)(CanBuildFrom[Iterable[GridRichNode], B, That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scanRight</span><span class="tparams">[<span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="z">z: B</span>)</span><span class="params">(<span name="op">op: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, B) ⇒ B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], B, That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd><dt>Annotations</dt><dd>
                <span class="name">@migration</span>
              
        </dd><dt>Migration</dt><dd class="cmt"><p><i>(Changed in version 2.9.0)</i> The behavior of <code>scanRight</code> has changed. The previous behavior can be reproduced with scanRight.reverse.</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarGridPimp#scheduleLocalCall" data-isabs="false">
      <a id="scheduleLocalCall[R](() ⇒ R,String):GridScheduleFuture[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scheduleLocalCall</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="s">s: () ⇒ R</span>, <span name="ptrn">ptrn: String</span>)</span><span class="result">: <span name="org.gridgain.grid.GridScheduleFuture" class="extype">GridScheduleFuture</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Schedules closure for execution using local cron-based scheduling.</p><div class="fullcomment"><div class="comment cmt"><p>Schedules closure for execution using local cron-based scheduling.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>Closure to schedule to run as a background cron-based job.</p></dd><dt class="param">ptrn</dt><dd class="cmt"><p>Scheduling pattern in UNIX cron format with optional prefix <code>{n1, n2}</code>
    where <code>n1</code> is delay of scheduling in seconds and <code>n2</code> is the number of execution. Both
    parameters are optional.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarGridPimp#scheduleLocalRun" data-isabs="false">
      <a id="scheduleLocalRun(() ⇒ Unit,String):org.gridgain.grid.GridScheduleFuture[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scheduleLocalRun</span><span class="params">(<span name="s">s: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="ptrn">ptrn: String</span>)</span><span class="result">: org.gridgain.grid.GridScheduleFuture[_]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Schedules closure for execution using local cron-based scheduling.</p><div class="fullcomment"><div class="comment cmt"><p>Schedules closure for execution using local cron-based scheduling.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>Closure to schedule to run as a background cron-based job.</p></dd><dt class="param">ptrn</dt><dd class="cmt"><p>Scheduling pattern in UNIX cron format with optional prefix <code>{n1, n2}</code>
    where <code>n1</code> is delay of scheduling in seconds and <code>n2</code> is the number of execution. Both
    parameters are optional.
</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#send$" data-isabs="false">
      <a id="send$(Seq[AnyRef],NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">send$</span><span class="params">(<span name="seq">seq: Seq[AnyRef]</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sends given object to the nodes in this projection.</p><div class="fullcomment"><div class="comment cmt"><p>Sends given object to the nodes in this projection.
</p></div><dl class="paramcmts block"><dt class="param">seq</dt><dd class="cmt"><p>Optional sequence of objects to send. If empty or <code>null</code> - this
     method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicates. If none provided or <code>null</code> -
     all nodes in the projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.send(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#send$" data-isabs="false">
      <a id="send$(AnyRef,NodeFilter*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">send$</span><span class="params">(<span name="obj">obj: AnyRef</span>, <span name="p">p: NodeFilter*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sends given object to the nodes in this projection.</p><div class="fullcomment"><div class="comment cmt"><p>Sends given object to the nodes in this projection.
</p></div><dl class="paramcmts block"><dt class="param">obj</dt><dd class="cmt"><p>Optional object to send. If <code>null</code> - this method is no-op.</p></dd><dt class="param">p</dt><dd class="cmt"><p>Optional node filter predicates. If none provided or <code>null</code> -
     all nodes in the projection will be used.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>org.gridgain.grid.GridProjection.send(...)</code>
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.Iterable#seq" data-isabs="false">
      <a id="seq:Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seq</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Iterable → GenIterable → Traversable → GenTraversable → Parallelizable → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#size" data-isabs="false">
      <a id="size:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">size</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#slice" data-isabs="false">
      <a id="slice(Int,Int):Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">slice</span><span class="params">(<span name="from">from: <span name="scala.Int" class="extype">Int</span></span>, <span name="until">until: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#sliding" data-isabs="false">
      <a id="sliding[B<span class='angle_bracket'>&gt;</span>:GridRichNode](Int,Int):Iterator[Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sliding</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="size">size: <span name="scala.Int" class="extype">Int</span></span>, <span name="step">step: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#sliding" data-isabs="false">
      <a id="sliding[B<span class='angle_bracket'>&gt;</span>:GridRichNode](Int):Iterator[Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sliding</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="size">size: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#span" data-isabs="false">
      <a id="span((GridRichNode) ⇒ Boolean):(Iterable[GridRichNode], Iterable[GridRichNode])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">span</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>])</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#splitAt" data-isabs="false">
      <a id="splitAt(Int):(Iterable[GridRichNode], Iterable[GridRichNode])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">splitAt</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>])</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#stringPrefix" data-isabs="false">
      <a id="stringPrefix:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">stringPrefix</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#sum" data-isabs="false">
      <a id="sum[B<span class='angle_bracket'>&gt;</span>:GridRichNode](Numeric[B]):B"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sum</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: Numeric[B]</span>)</span><span class="result">: B</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#tail" data-isabs="false">
      <a id="tail:Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tail</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#tails" data-isabs="false">
      <a id="tails:Iterator[Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tails</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#take" data-isabs="false">
      <a id="take(Int):Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">take</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#takeRight" data-isabs="false">
      <a id="takeRight(Int):Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeRight</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#takeWhile" data-isabs="false">
      <a id="takeWhile((GridRichNode) ⇒ Boolean):Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeWhile</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableLike</dd></dl></div>
    </li><li visbl="prt" name="scala.collection.IterableLike#thisCollection" data-isabs="false">
      <a id="thisCollection:Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">thisCollection</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[this] </dd><dt>Definition Classes</dt><dd>IterableLike → TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toAbsClosure" data-isabs="false">
      <a id="toAbsClosure(() ⇒ Unit):GridAbsClosure"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toAbsClosure</span><span class="params">(<span name="f">f: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridAbsClosure" class="extype">GridAbsClosure</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridAbsClosure</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridAbsClosure</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toAbsClosure2" data-isabs="false">
      <a id="toAbsClosure2(Runnable):GridAbsClosure"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toAbsClosure2</span><span class="params">(<span name="r">r: <span name="java.lang.Runnable" class="extype">Runnable</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridAbsClosure" class="extype">GridAbsClosure</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>java.lang.Runnable</code> to <code>GridAbsClosure</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>java.lang.Runnable</code> to <code>GridAbsClosure</code>.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Java runnable to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toAbsClosureX" data-isabs="false">
      <a id="toAbsClosureX(() ⇒ Unit):GridAbsClosureX"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toAbsClosureX</span><span class="params">(<span name="f">f: () ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridAbsClosureX" class="extype">GridAbsClosureX</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridAbsClosureX</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridAbsClosureX</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toAbsPredicate" data-isabs="false">
      <a id="toAbsPredicate(() ⇒ Boolean):GridAbsPredicate"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toAbsPredicate</span><span class="params">(<span name="f">f: () ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridAbsPredicate" class="extype">GridAbsPredicate</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala predicate to <code>GridAbsPredicate</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala predicate to <code>GridAbsPredicate</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toAbsPredicateX" data-isabs="false">
      <a id="toAbsPredicateX(() ⇒ Boolean):GridAbsPredicateX"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toAbsPredicateX</span><span class="params">(<span name="f">f: () ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridAbsPredicateX" class="extype">GridAbsPredicateX</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala predicate to <code>GridAbsPredicateX</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala predicate to <code>GridAbsPredicateX</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toArray" data-isabs="false">
      <a id="toArray[B<span class='angle_bracket'>&gt;</span>:GridRichNode](ClassManifest[B]):Array[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toArray</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: ClassManifest[B]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toBuffer" data-isabs="false">
      <a id="toBuffer[B<span class='angle_bracket'>&gt;</span>:GridRichNode]:Buffer[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toBuffer</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="result">: <span name="scala.collection.mutable.Buffer" class="extype">Buffer</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toClosure" data-isabs="false">
      <a id="toClosure[A, R]((A) ⇒ R):GridClosure[A, R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toClosure</span><span class="tparams">[<span name="A">A</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (A) ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridClosure" class="extype">GridClosure</span>[A, R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala closure to <code>GridClosure</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala closure to <code>GridClosure</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toClosure2" data-isabs="false">
      <a id="toClosure2[A1, A2, R]((A1, A2) ⇒ R):GridClosure2[A1, A2, R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toClosure2</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (A1, A2) ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridClosure2" class="extype">GridClosure2</span>[A1, A2, R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala closure to <code>GridClosure2</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala closure to <code>GridClosure2</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toClosure2X" data-isabs="false">
      <a id="toClosure2X[A1, A2, R]((A1, A2) ⇒ R):GridClosure2X[A1, A2, R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toClosure2X</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (A1, A2) ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridClosure2X" class="extype">GridClosure2X</span>[A1, A2, R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala closure to <code>GridClosure2X</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala closure to <code>GridClosure2X</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toClosure3" data-isabs="false">
      <a id="toClosure3[A1, A2, A3, R]((A1, A2, A3) ⇒ R):GridClosure3[A1, A2, A3, R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toClosure3</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (A1, A2, A3) ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridClosure3" class="extype">GridClosure3</span>[A1, A2, A3, R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala closure to <code>GridClosure3X</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala closure to <code>GridClosure3X</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toClosure3X" data-isabs="false">
      <a id="toClosure3X[A1, A2, A3, R]((A1, A2, A3) ⇒ R):GridClosure3X[A1, A2, A3, R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toClosure3X</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (A1, A2, A3) ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridClosure3X" class="extype">GridClosure3X</span>[A1, A2, A3, R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala closure to <code>GridClosure3X</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala closure to <code>GridClosure3X</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toClosureX" data-isabs="false">
      <a id="toClosureX[A, R]((A) ⇒ R):GridClosureX[A, R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toClosureX</span><span class="tparams">[<span name="A">A</span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: (A) ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridClosureX" class="extype">GridClosureX</span>[A, R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala closure to <code>GridClosureX</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala closure to <code>GridClosureX</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala closure to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="prt" name="scala.collection.IterableLike#toCollection" data-isabs="false">
      <a id="toCollection(Iterable[GridRichNode]):Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toCollection</span><span class="params">(<span name="repr">repr: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[this] </dd><dt>Definition Classes</dt><dd>IterableLike → TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toEntryPred" data-isabs="false">
      <a id="toEntryPred[K, V]((K, V) ⇒ Boolean):Function1[_ <span class='angle_bracket'>&gt;</span>: org.gridgain.grid.cache.GridCacheEntry[K,V], Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toEntryPred</span><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="params">(<span name="p">p: (K, V) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: Function1[_ <span class='angle_bracket'>&gt;</span>: org.gridgain.grid.cache.GridCacheEntry[K,V], Boolean]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from cache KV-pair predicate to cache entry predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from cache KV-pair predicate to cache entry predicate. Note that predicate
will use peek()
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>Cache KV-pair predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toInClosure" data-isabs="false">
      <a id="toInClosure[T]((T) ⇒ Unit):GridInClosure[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toInClosure</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (T) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridInClosure" class="extype">GridInClosure</span>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridInClosure</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridInClosure</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toInClosure2" data-isabs="false">
      <a id="toInClosure2[T1, T2]((T1, T2) ⇒ Unit):GridInClosure2[T1, T2]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toInClosure2</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="f">f: (T1, T2) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridInClosure2" class="extype">GridInClosure2</span>[T1, T2]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridInClosure2</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridInClosure2</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toInClosure2X" data-isabs="false">
      <a id="toInClosure2X[T1, T2]((T1, T2) ⇒ Unit):GridInClosure2X[T1, T2]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toInClosure2X</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="f">f: (T1, T2) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridInClosure2X" class="extype">GridInClosure2X</span>[T1, T2]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridInClosure2X</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridInClosure2X</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toInClosure3" data-isabs="false">
      <a id="toInClosure3[T1, T2, T3]((T1, T2, T3) ⇒ Unit):GridInClosure3[T1, T2, T3]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toInClosure3</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="f">f: (T1, T2, T3) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridInClosure3" class="extype">GridInClosure3</span>[T1, T2, T3]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridInClosure3</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridInClosure3</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toInClosure3X" data-isabs="false">
      <a id="toInClosure3X[T1, T2, T3]((T1, T2, T3) ⇒ Unit):GridInClosure3X[T1, T2, T3]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toInClosure3X</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="f">f: (T1, T2, T3) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridInClosure3X" class="extype">GridInClosure3X</span>[T1, T2, T3]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridInClosure3X</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridInClosure3X</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toInClosureX" data-isabs="false">
      <a id="toInClosureX[T]((T) ⇒ Unit):GridInClosureX[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toInClosureX</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (T) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridInClosureX" class="extype">GridInClosureX</span>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridInClosureX</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridInClosureX</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toIndexedSeq" data-isabs="false">
      <a id="toIndexedSeq[B<span class='angle_bracket'>&gt;</span>:GridRichNode]:IndexedSeq[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toIndexedSeq</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="result">: <span name="scala.collection.immutable.IndexedSeq" class="extype">IndexedSeq</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#toIterable" data-isabs="false">
      <a id="toIterable:Iterable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toIterable</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#toIterator" data-isabs="false">
      <a id="toIterator:Iterator[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toIterator</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toJavaCollection" data-isabs="false">
      <a id="toJavaCollection[A, B](Iterator[A],(A) ⇒ B):Collection[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toJavaCollection</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="i">i: <span name="scala.collection.Iterator" class="extype">Iterator</span>[A]</span>, <span name="f">f: (A) ⇒ B</span>)</span><span class="result">: <span name="java.util.Collection" class="extype">Collection</span>[B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Helper transformer from Scala iterator to Java collection.</p><div class="fullcomment"><div class="comment cmt"><p>Helper transformer from Scala iterator to Java collection.
</p></div><dl class="paramcmts block"><dt class="param">i</dt><dd class="cmt"><p>Scala iterator to transform.</p></dd><dt class="param">f</dt><dd class="cmt"><p>Transforming function.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toJavaCollection" data-isabs="false">
      <a id="toJavaCollection[A](Seq[A]):Collection[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toJavaCollection</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="s">s: <span name="scala.collection.Seq" class="extype">Seq</span>[A]</span>)</span><span class="result">: <span name="java.util.Collection" class="extype">Collection</span>[A]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Helper converter from Scala sequence to Java collection.</p><div class="fullcomment"><div class="comment cmt"><p>Helper converter from Scala sequence to Java collection.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>Scala sequence to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toJavaCollection" data-isabs="false">
      <a id="toJavaCollection[A, B](Seq[A],(A) ⇒ B):Collection[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toJavaCollection</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="s">s: <span name="scala.collection.Seq" class="extype">Seq</span>[A]</span>, <span name="f">f: (A) ⇒ B</span>)</span><span class="result">: <span name="java.util.Collection" class="extype">Collection</span>[B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Helper transformer from Scala sequence to Java collection.</p><div class="fullcomment"><div class="comment cmt"><p>Helper transformer from Scala sequence to Java collection.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>Scala sequence to transform.</p></dd><dt class="param">f</dt><dd class="cmt"><p>Transforming function.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toJob" data-isabs="false">
      <a id="toJob(() ⇒ Any):GridJob"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toJob</span><span class="params">(<span name="f">f: () ⇒ <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="org.gridgain.grid.GridJob" class="extype">GridJob</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridJob</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridJob</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toList" data-isabs="false">
      <a id="toList:List[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toList</span><span class="result">: List[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toMap" data-isabs="false">
      <a id="toMap[T, U](<span class='angle_bracket'>&lt;</span>:<span class='angle_bracket'>&lt;</span>[GridRichNode, (T, U)]):Map[T, U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toMap</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.Predef.<span class='angle_bracket'>&lt;</span>:<span class='angle_bracket'>&lt;</span>" class="extype"><span class='angle_bracket'>&lt;</span>:<span class='angle_bracket'>&lt;</span></span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, (T, U)]</span>)</span><span class="result">: <span name="scala.collection.immutable.Map" class="extype">Map</span>[T, U]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toMapper" data-isabs="false">
      <a id="toMapper[T1, T2<span class='angle_bracket'>&gt;</span>:GridRichNode]((Seq[T2]) ⇒ (T1) ⇒ T2):GridMapper[T1, T2]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toMapper</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="params">(<span name="f">f: (<span name="scala.collection.Seq" class="extype">Seq</span>[T2]) ⇒ (T1) ⇒ T2</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridMapper" class="extype">GridMapper</span>[T1, T2]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala mapping function to <code>GridMapper</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala mapping function to <code>GridMapper</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala mapping function.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toOutClosure" data-isabs="false">
      <a id="toOutClosure[R](() ⇒ R):GridOutClosure[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toOutClosure</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: () ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridOutClosure" class="extype">GridOutClosure</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridOutClosure</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridOutClosure</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toOutClosure2" data-isabs="false">
      <a id="toOutClosure2[R](Callable[R]):GridOutClosure[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toOutClosure2</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="c">c: <span name="java.util.concurrent.Callable" class="extype">Callable</span>[R]</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridOutClosure" class="extype">GridOutClosure</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>java.util.concurrent.Callable</code> to <code>GridOutClosure</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>java.util.concurrent.Callable</code> to <code>GridOutClosure</code>.
</p></div><dl class="paramcmts block"><dt class="param">c</dt><dd class="cmt"><p>Java callable to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toOutClosureX" data-isabs="false">
      <a id="toOutClosureX[R](() ⇒ R):GridOutClosureX[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toOutClosureX</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: () ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridOutClosureX" class="extype">GridOutClosureX</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function to <code>GridOutClosureX</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function to <code>GridOutClosureX</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toPredicate" data-isabs="false">
      <a id="toPredicate[T]((T) ⇒ Boolean):GridPredicate[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toPredicate</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (T) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridPredicate" class="extype">GridPredicate</span>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala predicate to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala predicate to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toPredicate2" data-isabs="false">
      <a id="toPredicate2[T1, T2]((T1, T2) ⇒ Boolean):GridPredicate2[T1, T2]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toPredicate2</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="f">f: (T1, T2) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridPredicate2" class="extype">GridPredicate2</span>[T1, T2]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala predicate to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala predicate to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toPredicate2X" data-isabs="false">
      <a id="toPredicate2X[T1, T2]((T1, T2) ⇒ Boolean):GridPredicate2X[T1, T2]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toPredicate2X</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="f">f: (T1, T2) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridPredicate2X" class="extype">GridPredicate2X</span>[T1, T2]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala predicate to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala predicate to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toPredicate3" data-isabs="false">
      <a id="toPredicate3[T1, T2, T3]((T1, T2, T3) ⇒ Boolean):GridPredicate3[T1, T2, T3]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toPredicate3</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="f">f: (T1, T2, T3) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridPredicate3" class="extype">GridPredicate3</span>[T1, T2, T3]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala predicate to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala predicate to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toPredicate32" data-isabs="false">
      <a id="toPredicate32[T1, T2, T3]((T1, T2, T3) ⇒ Boolean):GridPredicate3X[T1, T2, T3]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toPredicate32</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="f">f: (T1, T2, T3) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridPredicate3X" class="extype">GridPredicate3X</span>[T1, T2, T3]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala predicate to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala predicate to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toPredicateX" data-isabs="false">
      <a id="toPredicateX[T]((T) ⇒ Boolean):GridPredicateX[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toPredicateX</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (T) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridPredicateX" class="extype">GridPredicateX</span>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala predicate to Scala wrapping predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala predicate to Scala wrapping predicate.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>Scala predicate to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toReducer" data-isabs="false">
      <a id="toReducer[E, R]((Seq[E]) ⇒ R):GridReducer[E, R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toReducer</span><span class="tparams">[<span name="E">E</span>, <span name="R">R</span>]</span><span class="params">(<span name="r">r: (<span name="scala.collection.Seq" class="extype">Seq</span>[E]) ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridReducer" class="extype">GridReducer</span>[E, R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function and Java <code>GridReducer</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function and Java <code>GridReducer</code>.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toReducer2" data-isabs="false">
      <a id="toReducer2[E1, E2, R]((Seq[E1], Seq[E2]) ⇒ R):GridReducer2[E1, E2, R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toReducer2</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="R">R</span>]</span><span class="params">(<span name="r">r: (<span name="scala.collection.Seq" class="extype">Seq</span>[E1], <span name="scala.collection.Seq" class="extype">Seq</span>[E2]) ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridReducer2" class="extype">GridReducer2</span>[E1, E2, R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function and Java <code>GridReducer2</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function and Java <code>GridReducer2</code>.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toReducer3" data-isabs="false">
      <a id="toReducer3[E1, E2, E3, R]((Seq[E1], Seq[E2], Seq[E3]) ⇒ R):GridReducer3[E1, E2, E3, R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toReducer3</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>, <span name="E3">E3</span>, <span name="R">R</span>]</span><span class="params">(<span name="r">r: (<span name="scala.collection.Seq" class="extype">Seq</span>[E1], <span name="scala.collection.Seq" class="extype">Seq</span>[E2], <span name="scala.collection.Seq" class="extype">Seq</span>[E3]) ⇒ R</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridReducer3" class="extype">GridReducer3</span>[E1, E2, E3, R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala function and Java <code>GridReducer3</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala function and Java <code>GridReducer3</code>.
</p></div><dl class="paramcmts block"><dt class="param">r</dt><dd class="cmt"><p>Scala function to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toReturnable" data-isabs="false">
      <a id="toReturnable(Any):AnyRef { def ^^: Unit }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toReturnable</span><span class="params">(<span name="v">v: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: AnyRef { def ^^: Unit }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Introduction of <code>^^<code> operator for </code>Any<code> type that will call </code>break<code>.
</code></code></p><div class="fullcomment"><div class="comment cmt"><p>Introduction of <code>^^<code> operator for </code>Any<code> type that will call </code>break<code>.
</code></code></p></div><dl class="paramcmts block"><dt class="param">v</dt><dd class="cmt"><p><code>Any</code> value.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalaSeq" data-isabs="false">
      <a id="toScalaSeq[A](Collection[A]):Seq[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalaSeq</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="c">c: <span name="java.util.Collection" class="extype">Collection</span>[A]</span>)</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[A]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Helper converter from Java collection to Scala sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Helper converter from Java collection to Scala sequence.
</p></div><dl class="paramcmts block"><dt class="param">c</dt><dd class="cmt"><p>Java collection to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalaSeq" data-isabs="false">
      <a id="toScalaSeq[A](Iterable[A]):Seq[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalaSeq</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="i">i: <span name="java.lang.Iterable" class="extype">Iterable</span>[A]</span>)</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[A]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Helper converter from Java iterable to Scala sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Helper converter from Java iterable to Scala sequence.
</p></div><dl class="paramcmts block"><dt class="param">i</dt><dd class="cmt"><p>Java iterable to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalaSeq" data-isabs="false">
      <a id="toScalaSeq[A, B](Iterable[A],(A) ⇒ B):Seq[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalaSeq</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="i">i: <span name="java.lang.Iterable" class="extype">Iterable</span>[A]</span>, <span name="f">f: (A) ⇒ B</span>)</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Helper transformer from Java iterable to Scala sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Helper transformer from Java iterable to Scala sequence.
</p></div><dl class="paramcmts block"><dt class="param">i</dt><dd class="cmt"><p>Java iterable to transform.</p></dd><dt class="param">f</dt><dd class="cmt"><p>Transforming function.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalaSeq" data-isabs="false">
      <a id="toScalaSeq[A](Iterator[A]):Seq[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalaSeq</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="i">i: <span name="java.util.Iterator" class="extype">Iterator</span>[A]</span>)</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[A]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Helper converter from Java iterator to Scala sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Helper converter from Java iterator to Scala sequence.
</p></div><dl class="paramcmts block"><dt class="param">i</dt><dd class="cmt"><p>Java iterator to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalaSeq" data-isabs="false">
      <a id="toScalaSeq[A, B](Iterator[A],(A) ⇒ B):Seq[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalaSeq</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="i">i: <span name="java.util.Iterator" class="extype">Iterator</span>[A]</span>, <span name="f">f: (A) ⇒ B</span>)</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Helper transformer from Java iterator to Scala sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Helper transformer from Java iterator to Scala sequence.
</p></div><dl class="paramcmts block"><dt class="param">i</dt><dd class="cmt"><p>Java iterator to transform.</p></dd><dt class="param">f</dt><dd class="cmt"><p>Transforming function.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalaSeq" data-isabs="false">
      <a id="toScalaSeq[A, B](Collection[A],(A) ⇒ B):Seq[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalaSeq</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="c">c: <span name="java.util.Collection" class="extype">Collection</span>[A]</span>, <span name="f">f: (A) ⇒ B</span>)</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Helper transformer from Java collection to Scala sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Helper transformer from Java collection to Scala sequence.
</p></div><dl class="paramcmts block"><dt class="param">c</dt><dd class="cmt"><p>Java collection to transform.</p></dd><dt class="param">f</dt><dd class="cmt"><p>Transforming function.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalarCache" data-isabs="false">
      <a id="toScalarCache[K, V](GridCache[K, V]):ScalarCachePimp[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalarCache</span><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="params">(<span name="impl">impl: <span name="org.gridgain.grid.cache.GridCache" class="extype">GridCache</span>[K, V]</span>)</span><span class="result">: <a name="org.gridgain.scalar.pimps.ScalarCachePimp" class="extype" href="ScalarCachePimp.html">ScalarCachePimp</a>[K, V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridCache</code> to <code>ScalarCachePimp</code> &quot;pimp&quot;.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridCache</code> to <code>ScalarCachePimp</code> &quot;pimp&quot;.
</p></div><dl class="paramcmts block"><dt class="param">impl</dt><dd class="cmt"><p>Grid cache to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalarCacheProjection" data-isabs="false">
      <a id="toScalarCacheProjection[K, V](GridCacheProjection[K, V]):ScalarCacheProjectionPimp[K, V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalarCacheProjection</span><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="params">(<span name="impl">impl: <span name="org.gridgain.grid.cache.GridCacheProjection" class="extype">GridCacheProjection</span>[K, V]</span>)</span><span class="result">: <a name="org.gridgain.scalar.pimps.ScalarCacheProjectionPimp" class="extype" href="ScalarCacheProjectionPimp.html">ScalarCacheProjectionPimp</a>[K, V]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridCacheProjection</code> to <code>ScalarCacheProjectionPimp</code> &quot;pimp&quot;.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridCacheProjection</code> to <code>ScalarCacheProjectionPimp</code> &quot;pimp&quot;.
</p></div><dl class="paramcmts block"><dt class="param">impl</dt><dd class="cmt"><p>Grid cache projection to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalarGrid" data-isabs="false">
      <a id="toScalarGrid(Grid):ScalarGridPimp"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalarGrid</span><span class="params">(<span name="impl">impl: <span name="org.gridgain.grid.Grid" class="extype">Grid</span></span>)</span><span class="result">: <a name="org.gridgain.scalar.pimps.ScalarGridPimp" class="extype" href="">ScalarGridPimp</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>Grid</code> to <code>ScalarGridPimp</code> &quot;pimp&quot;.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>Grid</code> to <code>ScalarGridPimp</code> &quot;pimp&quot;.
</p></div><dl class="paramcmts block"><dt class="param">impl</dt><dd class="cmt"><p>Grid to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalarProjection" data-isabs="false">
      <a id="toScalarProjection(GridProjection):ScalarProjectionPimp[GridProjection]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalarProjection</span><span class="params">(<span name="impl">impl: <span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span></span>)</span><span class="result">: <a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a>[<span name="org.gridgain.grid.GridProjection" class="extype">GridProjection</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridProjection</code> to <code>ScalarProjectionPimp</code> &quot;pimp&quot;.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridProjection</code> to <code>ScalarProjectionPimp</code> &quot;pimp&quot;.
</p></div><dl class="paramcmts block"><dt class="param">impl</dt><dd class="cmt"><p>Grid projection to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toScalarRichNode" data-isabs="false">
      <a id="toScalarRichNode(GridRichNode):ScalarRichNodePimp"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalarRichNode</span><span class="params">(<span name="impl">impl: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>)</span><span class="result">: <a name="org.gridgain.scalar.pimps.ScalarRichNodePimp" class="extype" href="ScalarRichNodePimp.html">ScalarRichNodePimp</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from <code>GridRichNode</code> to <code>ScalarRichNodePimp</code> &quot;pimp&quot;.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from <code>GridRichNode</code> to <code>ScalarRichNodePimp</code> &quot;pimp&quot;.
</p></div><dl class="paramcmts block"><dt class="param">impl</dt><dd class="cmt"><p>Rich node to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toSeq" data-isabs="false">
      <a id="toSeq:Seq[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toSeq</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableOnce#toSet" data-isabs="false">
      <a id="toSet[B<span class='angle_bracket'>&gt;</span>:GridRichNode]:Set[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toSet</span><span class="tparams">[<span name="B">B <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>]</span><span class="result">: <span name="scala.collection.immutable.Set" class="extype">Set</span>[B]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#toStream" data-isabs="false">
      <a id="toStream:Stream[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toStream</span><span class="result">: <span name="scala.collection.immutable.Stream" class="extype">Stream</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#toTraversable" data-isabs="false">
      <a id="toTraversable:Traversable[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toTraversable</span><span class="result">: <span name="scala.collection.Traversable" class="extype">Traversable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → TraversableOnce → GenTraversableOnce</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toTuple2" data-isabs="false">
      <a id="toTuple2[A, B]((A, B)):GridTuple2[A, B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toTuple2</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="t">t: (A, B)</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridTuple2" class="extype">GridTuple2</span>[A, B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala tuple to <code>GridTuple2</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala tuple to <code>GridTuple2</code>.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Scala tuple to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toTuple2x" data-isabs="false">
      <a id="toTuple2x[T1, T2]((T1, T2)):AnyRef { ... /* 5 definitions in type refinement */ }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toTuple2x</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="t">t: (T1, T2)</span>)</span><span class="result">: AnyRef { ... /* 5 definitions in type refinement */ }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extension for <code>Tuple2</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Extension for <code>Tuple2</code>.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Tuple to improve.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toTuple3" data-isabs="false">
      <a id="toTuple3[A, B, C]((A, B, C)):GridTuple3[A, B, C]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toTuple3</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="t">t: (A, B, C)</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridTuple3" class="extype">GridTuple3</span>[A, B, C]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala tuple to <code>GridTuple3</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala tuple to <code>GridTuple3</code>.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Scala tuple to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toTuple3x" data-isabs="false">
      <a id="toTuple3x[T1, T2, T3]((T1, T2, T3)):AnyRef { ... /* 6 definitions in type refinement */ }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toTuple3x</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="t">t: (T1, T2, T3)</span>)</span><span class="result">: AnyRef { ... /* 6 definitions in type refinement */ }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extension for <code>Tuple3</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Extension for <code>Tuple3</code>.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Tuple to improve.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toTuple4" data-isabs="false">
      <a id="toTuple4[A, B, C, D]((A, B, C, D)):GridTuple4[A, B, C, D]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toTuple4</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="D">D</span>]</span><span class="params">(<span name="t">t: (A, B, C, D)</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridTuple4" class="extype">GridTuple4</span>[A, B, C, D]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala tuple to <code>GridTuple4</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala tuple to <code>GridTuple4</code>.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Scala tuple to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toTuple5" data-isabs="false">
      <a id="toTuple5[A, B, C, D, E]((A, B, C, D, E)):GridTuple5[A, B, C, D, E]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toTuple5</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="D">D</span>, <span name="E">E</span>]</span><span class="params">(<span name="t">t: (A, B, C, D, E)</span>)</span><span class="result">: <span name="org.gridgain.grid.lang.GridTuple5" class="extype">GridTuple5</span>[A, B, C, D, E]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from Scala tuple to <code>GridTuple5</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from Scala tuple to <code>GridTuple5</code>.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Scala tuple to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toVarArgs" data-isabs="false">
      <a id="toVarArgs[T](Seq[(T) ⇒ Boolean]):Seq[org.gridgain.grid.lang.GridPredicate[_ <span class='angle_bracket'>&gt;</span>: T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toVarArgs</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="s">s: <span name="scala.collection.Seq" class="extype">Seq</span>[(T) ⇒ <span name="scala.Boolean" class="extype">Boolean</span>]</span>)</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[org.gridgain.grid.lang.GridPredicate[_ <span class='angle_bracket'>&gt;</span>: T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from vararg of one-argument Scala functions to Java <code>GridPredicate</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from vararg of one-argument Scala functions to Java <code>GridPredicate</code>s.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>Sequence of one-argument Scala functions to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toVarArgs2" data-isabs="false">
      <a id="toVarArgs2[T1, T2](Seq[(T1, T2) ⇒ Boolean]):Seq[org.gridgain.grid.lang.GridPredicate2[_ <span class='angle_bracket'>&gt;</span>: T1, _ <span class='angle_bracket'>&gt;</span>: T2]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toVarArgs2</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="s">s: <span name="scala.collection.Seq" class="extype">Seq</span>[(T1, T2) ⇒ <span name="scala.Boolean" class="extype">Boolean</span>]</span>)</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[org.gridgain.grid.lang.GridPredicate2[_ <span class='angle_bracket'>&gt;</span>: T1, _ <span class='angle_bracket'>&gt;</span>: T2]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from vararg of two-argument Scala functions to Java <code>GridPredicate2</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from vararg of two-argument Scala functions to Java <code>GridPredicate2</code>s.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>Sequence of two-argument Scala functions to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#toVarArgs3" data-isabs="false">
      <a id="toVarArgs3[T1, T2, T3](Seq[(T1, T2, T3) ⇒ Boolean]):Seq[org.gridgain.grid.lang.GridPredicate3[_ <span class='angle_bracket'>&gt;</span>: T1, _ <span class='angle_bracket'>&gt;</span>: T2, _ <span class='angle_bracket'>&gt;</span>: T3]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toVarArgs3</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="s">s: <span name="scala.collection.Seq" class="extype">Seq</span>[(T1, T2, T3) ⇒ <span name="scala.Boolean" class="extype">Boolean</span>]</span>)</span><span class="result">: <span name="scala.collection.Seq" class="extype">Seq</span>[org.gridgain.grid.lang.GridPredicate3[_ <span class='angle_bracket'>&gt;</span>: T1, _ <span class='angle_bracket'>&gt;</span>: T2, _ <span class='angle_bracket'>&gt;</span>: T3]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit converter from vararg of three-argument Scala functions to Java <code>GridPredicate3</code>s.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit converter from vararg of three-argument Scala functions to Java <code>GridPredicate3</code>s.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>Sequence of three-argument Scala functions to convert.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.generic.GenericTraversableTemplate#transpose" data-isabs="false">
      <a id="transpose[B]((GridRichNode) ⇒ GenTraversableOnce[B]):Iterable[Iterable[B]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transpose</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="asTraversable">asTraversable: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.collection.GenTraversableOnce" class="extype">GenTraversableOnce</span>[B]</span>)</span><span class="result">: <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[B]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenericTraversableTemplate</dd><dt>Annotations</dt><dd>
                <span class="name">@migration</span>
              
        </dd><dt>Migration</dt><dd class="cmt"><p><i>(Changed in version 2.9.0)</i> <code>transpose</code> throws an <code>IllegalArgumentException</code> if collections are not uniformly sized.</p></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#tuple2DotScala" data-isabs="false">
      <a id="tuple2DotScala[A, B](GridTuple2[A, B]):AnyRef { def scala: (A, B) }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tuple2DotScala</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="params">(<span name="t">t: <span name="org.gridgain.grid.lang.GridTuple2" class="extype">GridTuple2</span>[A, B]</span>)</span><span class="result">: AnyRef { def scala: (A, B) }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Java-side tuple to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#tuple3DotScala" data-isabs="false">
      <a id="tuple3DotScala[A, B, C](GridTuple3[A, B, C]):AnyRef { def scala: (A, B, C) }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tuple3DotScala</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="t">t: <span name="org.gridgain.grid.lang.GridTuple3" class="extype">GridTuple3</span>[A, B, C]</span>)</span><span class="result">: AnyRef { def scala: (A, B, C) }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Java-side tuple to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#tuple4DotScala" data-isabs="false">
      <a id="tuple4DotScala[A, B, C, D](GridTuple4[A, B, C, D]):AnyRef { def scala: (A, B, C, D) }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tuple4DotScala</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="D">D</span>]</span><span class="params">(<span name="t">t: <span name="org.gridgain.grid.lang.GridTuple4" class="extype">GridTuple4</span>[A, B, C, D]</span>)</span><span class="result">: AnyRef { def scala: (A, B, C, D) }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Java-side tuple to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.ScalarConversions#tuple5DotScala" data-isabs="false">
      <a id="tuple5DotScala[A, B, C, D, E](GridTuple5[A, B, C, D, E]):AnyRef { def scala: (A, B, C, D, E) }"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tuple5DotScala</span><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>, <span name="C">C</span>, <span name="D">D</span>, <span name="E">E</span>]</span><span class="params">(<span name="t">t: <span name="org.gridgain.grid.lang.GridTuple5" class="extype">GridTuple5</span>[A, B, C, D, E]</span>)</span><span class="result">: AnyRef { def scala: (A, B, C, D, E) }</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pimp for adding explicit conversion method <code>scala</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pimp for adding explicit conversion method <code>scala</code>.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Java-side tuple to pimp.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.generic.GenericTraversableTemplate#unzip" data-isabs="false">
      <a id="unzip[A1, A2]((GridRichNode) ⇒ (A1, A2)):(Iterable[A1], Iterable[A2])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unzip</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="asPair">asPair: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ (A1, A2)</span>)</span><span class="result">: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[A1], <span name="scala.collection.Iterable" class="extype">Iterable</span>[A2])</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenericTraversableTemplate</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.generic.GenericTraversableTemplate#unzip3" data-isabs="false">
      <a id="unzip3[A1, A2, A3]((GridRichNode) ⇒ (A1, A2, A3)):(Iterable[A1], Iterable[A2], Iterable[A3])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unzip3</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="asTriple">asTriple: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ (A1, A2, A3)</span>)</span><span class="result">: (<span name="scala.collection.Iterable" class="extype">Iterable</span>[A1], <span name="scala.collection.Iterable" class="extype">Iterable</span>[A2], <span name="scala.collection.Iterable" class="extype">Iterable</span>[A3])</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>GenericTraversableTemplate</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarProjectionPimp#value" data-isabs="false">
      <a id="value:Grid"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">value</span><span class="result">: <span name="org.gridgain.grid.Grid" class="extype">Grid</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a> → PimpedType</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#view" data-isabs="false">
      <a id="view(Int,Int):IterableView[GridRichNode, Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">view</span><span class="params">(<span name="from">from: <span name="scala.Int" class="extype">Int</span></span>, <span name="until">until: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.collection.IterableView" class="extype">IterableView</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#view" data-isabs="false">
      <a id="view:IterableView[GridRichNode, Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">view</span><span class="result">: <span name="scala.collection.IterableView" class="extype">IterableView</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → TraversableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarTaskThreadContext#withCheckpointSpi$" data-isabs="false">
      <a id="withCheckpointSpi$(String):Grid"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withCheckpointSpi$</span><span class="params">(<span name="spiName">spiName: String</span>)</span><span class="result">: <span name="org.gridgain.grid.Grid" class="extype">Grid</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Properly typed version of <code>GridProjection#withCheckpointSpi(...)</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Properly typed version of <code>GridProjection#withCheckpointSpi(...)</code> method.
</p></div><dl class="paramcmts block"><dt class="param">spiName</dt><dd class="cmt"><p>Name of the SPI.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="extype" href="ScalarTaskThreadContext.html">ScalarTaskThreadContext</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarTaskThreadContext#withFailoverSpi$" data-isabs="false">
      <a id="withFailoverSpi$(String):Grid"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFailoverSpi$</span><span class="params">(<span name="spiName">spiName: String</span>)</span><span class="result">: <span name="org.gridgain.grid.Grid" class="extype">Grid</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Properly typed version of <code>GridProjection#withFailoverSpi(...)</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Properly typed version of <code>GridProjection#withFailoverSpi(...)</code> method.
</p></div><dl class="paramcmts block"><dt class="param">spiName</dt><dd class="cmt"><p>Name of the SPI.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="extype" href="ScalarTaskThreadContext.html">ScalarTaskThreadContext</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.TraversableLike#withFilter" data-isabs="false">
      <a id="withFilter((GridRichNode) ⇒ Boolean):FilterMonadic[GridRichNode, Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFilter</span><span class="params">(<span name="p">p: (<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.collection.generic.FilterMonadic" class="extype">FilterMonadic</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>TraversableLike → FilterMonadic</dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarTaskThreadContext#withLoadBalancingSpi$" data-isabs="false">
      <a id="withLoadBalancingSpi$(String):Grid"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withLoadBalancingSpi$</span><span class="params">(<span name="spiName">spiName: String</span>)</span><span class="result">: <span name="org.gridgain.grid.Grid" class="extype">Grid</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Properly typed version of <code>GridProjection#withLoadBalancingSpi(...)</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Properly typed version of <code>GridProjection#withLoadBalancingSpi(...)</code> method.
</p></div><dl class="paramcmts block"><dt class="param">spiName</dt><dd class="cmt"><p>Name of the SPI.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="extype" href="ScalarTaskThreadContext.html">ScalarTaskThreadContext</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarTaskThreadContext#withName$" data-isabs="false">
      <a id="withName$(String):Grid"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withName$</span><span class="params">(<span name="taskName">taskName: String</span>)</span><span class="result">: <span name="org.gridgain.grid.Grid" class="extype">Grid</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Properly typed version of <code>GridProjection#withName(...)</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Properly typed version of <code>GridProjection#withName(...)</code> method.
</p></div><dl class="paramcmts block"><dt class="param">taskName</dt><dd class="cmt"><p>Name of the task.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="extype" href="ScalarTaskThreadContext.html">ScalarTaskThreadContext</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarTaskThreadContext#withResultClosure$" data-isabs="false">
      <a id="withResultClosure$((GridJobResult, List[GridJobResult]) ⇒ GridJobResultPolicy):Grid"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withResultClosure$</span><span class="params">(<span name="f">f: (<span name="org.gridgain.grid.GridJobResult" class="extype">GridJobResult</span>, <span name="java.util.List" class="extype">List</span>[<span name="org.gridgain.grid.GridJobResult" class="extype">GridJobResult</span>]) ⇒ <span name="org.gridgain.grid.GridJobResultPolicy" class="extype">GridJobResultPolicy</span></span>)</span><span class="result">: <span name="org.gridgain.grid.Grid" class="extype">Grid</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Properly typed version of <code>GridProjection#withResultClosure(...)</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Properly typed version of <code>GridProjection#withResultClosure(...)</code> method.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="extype" href="ScalarTaskThreadContext.html">ScalarTaskThreadContext</a></dd></dl></div>
    </li><li visbl="pub" name="org.gridgain.scalar.pimps.ScalarTaskThreadContext#withTopologySpi$" data-isabs="false">
      <a id="withTopologySpi$(String):Grid"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withTopologySpi$</span><span class="params">(<span name="spiName">spiName: String</span>)</span><span class="result">: <span name="org.gridgain.grid.Grid" class="extype">Grid</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Properly typed version of <code>GridProjection#withTopologySpi(...)</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Properly typed version of <code>GridProjection#withTopologySpi(...)</code> method.
</p></div><dl class="paramcmts block"><dt class="param">spiName</dt><dd class="cmt"><p>Name of the SPI.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="extype" href="ScalarTaskThreadContext.html">ScalarTaskThreadContext</a></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#zip" data-isabs="false">
      <a id="zip[A1<span class='angle_bracket'>&gt;</span>:GridRichNode, B, That](GenIterable[B])(CanBuildFrom[Iterable[GridRichNode], (A1, B), That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>, <span name="B">B</span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.GenIterable" class="extype">GenIterable</span>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], (A1, B), That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#zipAll" data-isabs="false">
      <a id="zipAll[B, A1<span class='angle_bracket'>&gt;</span>:GridRichNode, That](GenIterable[B],A1,B)(CanBuildFrom[Iterable[GridRichNode], (A1, B), That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zipAll</span><span class="tparams">[<span name="B">B</span>, <span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <span name="scala.collection.GenIterable" class="extype">GenIterable</span>[B]</span>, <span name="thisElem">thisElem: A1</span>, <span name="thatElem">thatElem: B</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], (A1, B), That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike</dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#zipWithIndex" data-isabs="false">
      <a id="zipWithIndex[A1<span class='angle_bracket'>&gt;</span>:GridRichNode, That](CanBuildFrom[Iterable[GridRichNode], (A1, Int), That]):That"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zipWithIndex</span><span class="tparams">[<span name="A1">A1 <span class='angle_bracket'>&gt;</span>: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>, <span name="That">That</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <span name="scala.collection.generic.CanBuildFrom" class="extype">CanBuildFrom</span>[<span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>], (A1, <span name="scala.Int" class="extype">Int</span>), That]</span>)</span><span class="result">: That</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike → GenIterableLike</dd></dl></div>
    </li></ol>
            </div>

        <div class="values members" id="values">
              <h3>Deprecated Value Members</h3>
              <ol><li visbl="pub" name="scala.collection.IterableLike#elements" data-isabs="false">
      <a id="elements:Iterator[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.8.0) use iterator' instead">elements</span><span class="result">: <span name="scala.collection.Iterator" class="extype">Iterator</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.8.0)</i> use <code>iterator' instead</code></p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#first" data-isabs="false">
      <a id="first:GridRichNode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.8.0) use head' instead">first</span><span class="result">: <span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.8.0)</i> use <code>head' instead</code></p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#firstOption" data-isabs="false">
      <a id="firstOption:Option[GridRichNode]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.8.0) use headOption' instead">firstOption</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.8.0)</i> use <code>headOption' instead</code></p></dd></dl></div>
    </li><li visbl="pub" name="scala.collection.IterableLike#projection" data-isabs="false">
      <a id="projection:IterableView[GridRichNode, Iterable[GridRichNode]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.8.0) use view' instead">projection</span><span class="result">: <span name="scala.collection.IterableView" class="extype">IterableView</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>IterableLike</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.8.0)</i> use <code>view' instead</code></p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="parent">
              <h3>Inherited from <a name="org.gridgain.scalar.pimps.ScalarProjectionPimp" class="extype" href="ScalarProjectionPimp.html">ScalarProjectionPimp</a>[<span name="org.gridgain.grid.Grid" class="extype">Grid</span>]</h3>
            </div><div name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="parent">
              <h3>Inherited from <a name="org.gridgain.scalar.pimps.ScalarTaskThreadContext" class="extype" href="ScalarTaskThreadContext.html">ScalarTaskThreadContext</a>[<span name="org.gridgain.grid.Grid" class="extype">Grid</span>]</h3>
            </div><div name="org.gridgain.scalar.ScalarConversions" class="parent">
              <h3>Inherited from <a name="org.gridgain.scalar.ScalarConversions" class="extype" href="../ScalarConversions.html">ScalarConversions</a></h3>
            </div><div name="scala.collection.Iterable" class="parent">
              <h3>Inherited from <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</h3>
            </div><div name="scala.collection.IterableLike" class="parent">
              <h3>Inherited from <span name="scala.collection.IterableLike" class="extype">IterableLike</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</h3>
            </div><div name="scala.Equals" class="parent">
              <h3>Inherited from <span name="scala.Equals" class="extype">Equals</span></h3>
            </div><div name="scala.collection.GenIterable" class="parent">
              <h3>Inherited from <span name="scala.collection.GenIterable" class="extype">GenIterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</h3>
            </div><div name="scala.collection.GenIterableLike" class="parent">
              <h3>Inherited from <span name="scala.collection.GenIterableLike" class="extype">GenIterableLike</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</h3>
            </div><div name="scala.collection.Traversable" class="parent">
              <h3>Inherited from <span name="scala.collection.Traversable" class="extype">Traversable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</h3>
            </div><div name="scala.collection.GenTraversable" class="parent">
              <h3>Inherited from <span name="scala.collection.GenTraversable" class="extype">GenTraversable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</h3>
            </div><div name="scala.collection.generic.GenericTraversableTemplate" class="parent">
              <h3>Inherited from <span name="scala.collection.generic.GenericTraversableTemplate" class="extype">GenericTraversableTemplate</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>]</h3>
            </div><div name="scala.collection.TraversableLike" class="parent">
              <h3>Inherited from <span name="scala.collection.TraversableLike" class="extype">TraversableLike</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</h3>
            </div><div name="scala.collection.GenTraversableLike" class="parent">
              <h3>Inherited from <span name="scala.collection.GenTraversableLike" class="extype">GenTraversableLike</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</h3>
            </div><div name="scala.collection.Parallelizable" class="parent">
              <h3>Inherited from <span name="scala.collection.Parallelizable" class="extype">Parallelizable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.parallel.ParIterable" class="extype">ParIterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</h3>
            </div><div name="scala.collection.TraversableOnce" class="parent">
              <h3>Inherited from <span name="scala.collection.TraversableOnce" class="extype">TraversableOnce</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</h3>
            </div><div name="scala.collection.GenTraversableOnce" class="parent">
              <h3>Inherited from <span name="scala.collection.GenTraversableOnce" class="extype">GenTraversableOnce</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]</h3>
            </div><div name="scala.collection.generic.FilterMonadic" class="parent">
              <h3>Inherited from <span name="scala.collection.generic.FilterMonadic" class="extype">FilterMonadic</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</h3>
            </div><div name="scala.collection.generic.HasNewBuilder" class="parent">
              <h3>Inherited from <span name="scala.collection.generic.HasNewBuilder" class="extype">HasNewBuilder</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>, <span name="scala.collection.Iterable" class="extype">Iterable</span>[<span name="org.gridgain.grid.GridRichNode" class="extype">GridRichNode</span>]]</h3>
            </div><div name="scalaz.PimpedType" class="parent">
              <h3>Inherited from <span name="scalaz.PimpedType" class="extype">PimpedType</span>[<span name="org.gridgain.grid.Grid" class="extype">Grid</span>]</h3>
            </div><div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    
                
                    <table style="padding: 30px 10px 10px 10px; width: 100%">
                    <tr>
                        <td align="left" valign="center">
                            <nobr>GridGain - Real Time Big Data</nobr>
                            <br>
                            Version: <b>4.0.3</b>, Build: <b>14052012</b>
                            <br>
                            <a target=_blank href="http://www.gridgain.com"><nobr>2012 Copyright &#169; GridGain Systems</nobr></a>
                        </td>
                        <td width="45%">&nbsp;</td>
                        <td align="center" valign="center">
                            <table border="0">
                            <tr>
                                <td>
                                    <nobr>Follow us:&nbsp;&nbsp;</nobr>
                                </td>
                                <td style="padding-right: 5px">
                                    <a target=github class='img_link' href='https://github.com/gridgain/gridgain'>
                                        <img border=0 align=absmiddle src='http://www.gridgain.com/images/github_cat_31x28.gif' alt='Follow GridGain on Github'>
                                    </a>
                                </td>
                                <td style="padding-right: 5px">
                                    <a target=facebook class='img_link' href='http://www.facebook.com/profile.php?id=6458239494'>
                                        <img border=0 align=absmiddle src='http://www.gridgain.com/images/facebook_small.png' alt='Follow GridGain on Facebook'>
                                    </a>
                                </td>
                                <td style="padding-right: 5px">
                                    <a class='img_link' target=meetup href='http://www.meetup.com/GridGain-Bay-Area-Meetup-Group'>
                                        <img border=0 align=absmiddle src='http://www.gridgain.com/images/meetup_logo_small.png' alt='Join GridGain User Group'/>
                                    </a>
                                </td>
                                <td style="padding-right: 5px">
                                    <a class='img_link' target=twitter href='http://www.twitter.com/gridgain'>
                                        <img border=0 align=absmiddle src='http://www.gridgain.com/images/twitter.gif' alt='Follow GridGain on Twitter'/>
                                    </a>
                                </td>
                                <td>
                                    <a class='img_link' target=vimeo href='http://www.vimeo.com/gridgain'>
                                        <img border=0 align=absmiddle src='http://www.gridgain.com/images/vimeo.png' alt='Follow GridGain on Vimeo'/>
                                    </a>
                                </td>
                            </tr>
                            </table>
                        </td>
                        <td width="50%">&nbsp;</td>
                        <td align="right" valign="center">
                            <a class="img-link" target=_blank href="http://www.gridgain.com">
                                <img border="0" src="http://www.gridgain.com/images/logo/logo_small.png">
                            </a>
                        </td>
                    </tr>
                    </table>
                
            <script type='text/javascript'>SyntaxHighlighter.all();dp.SyntaxHighlighter.HighlightAll('code');</script>
</body>

      </html>